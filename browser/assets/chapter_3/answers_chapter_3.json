{
  "answers": [
    {
      "number": 1,
      "answers": [
        "E"
      ],
      "explanation": " An enum must declare its values before any members. For this reason, lines 2 and 3 are reversed. Line 5 is missing parentheses required for a record declaration. Line 6 is not allowed, as records do not allow instance variables. Line 8 is incorrect because only static initializers, not instance initializers, are allowed in records. Since there are at least four lines that contain errors, option E is correct."
    },
    {
      "number": 2,
      "answers": [
        "C",
        "E",
        "G"
      ],
      "explanation": " A sealed subclass must be declared final, sealed, or non-sealed, making options C, E, and G correct."
    },
    {
      "number": 3,
      "answers": [
        "F"
      ],
      "explanation": " The program does not compile because Story is marked final, which means it cannot be extended by Adventure, making option F correct. If the final modifier were removed, the rest of the code would compile and print 93 at runtime."
    },
    {
      "number": 4,
      "answers": [
        "C",
        "F"
      ],
      "explanation": " A class can start with a comment, an optional package statement, or an import statement if there is no package statement. It cannot start with a variable definition or method declaration, since those cannot be declared outside a type. Therefore, options C and F are correct."
    },
    {
      "number": 5,
      "answers": [
        "C",
        "E"
      ],
      "explanation": " An abstract method cannot include the final or private modifier. If a method contained either of these modifiers, then no concrete subclass would ever be able to override it with an implementation. For these reasons, options A and B are incorrect. Option D is also incorrect because the default keyword applies to concrete interface methods, not abstract methods. Option F is incorrect because there is no concrete modifier. That leaves options C and E as the correct answers. The protected, package, and public access modifiers can each be applied to abstract methods."
    },
    {
      "number": 6,
      "answers": [
        "D"
      ],
      "explanation": " On line 5, the variable trees is assigned a value of 5f. On line 6 it is added to an int value, which is promoted to float. The program then prints 15.0, making option D correct. Although accessing a static variable with an instance reference is not recommended, it is allowed on line 6."
    },
    {
      "number": 7,
      "answers": [
        "E"
      ],
      "explanation": " The public access modifier allows access to members in the same class, package, subclass, or even classes in other packages, whereas the private modifier allows access only to members in the same class. Therefore, the public access modifier allows access to everything the private access modifier does, and more, making option E the correct answer. Options A, B, C, and D are incorrect because the first term is a more restrictive access modifier than the second term."
    },
    {
      "number": 8,
      "answers": [
        "F"
      ],
      "explanation": " There is no modifier that can prevent a default method from being overridden in a class implementing an interface, making option F correct."
    },
    {
      "number": 9,
      "answers": [
        "B"
      ],
      "explanation": " Notice in this question that main() is not a static method; therefore, it can access both class and instance variables. It can also access the local variable args. Since there are two class variables, two instance variables, and one local variable available, option B is the correct answer."
    },
    {
      "number": 10,
      "answers": [
        "B",
        "D"
      ],
      "explanation": " Option A is incorrect because new cannot be used to declare a type. Option C is incorrect because null is a literal and cannot be used as the return type. Options E and F are incorrect because a void method cannot return a value. That leaves options B and D as the correct answers. Note that 10 can be returned as an int or implicitly promoted to a long, without issue."
    },
    {
      "number": 11,
      "answers": [
        "C",
        "E"
      ],
      "explanation": " Trick question! Options A, B, and D are not even constructors. Options A and B are static methods, whereas option D is a method that happens to have the same name as the class. Option C is the only valid constructor. As for the output, the key is that Java uses “pass by value” to send object references to methods. Since the Phone reference p was reassigned in the first line of the sendHome() method, any changes to the p reference were made to a new object. In other words, no changes in the sendHome() method affected the object that was passed in. Therefore, the value of size was the same before and after the method call. In this program, this.size is initialized with a default value of 0 and never changed, making option E the other correct answer."
    },
    {
      "number": 12,
      "answers": [
        "C",
        "F"
      ],
      "explanation": " Options A and E are incorrect because the new keyword before Pterodactyl is required to create an instance of the member inner class Pterodactyl using a member of the outer class Dinosaur. Option B is incorrect, as this is not a valid way to instantiate a member inner class. Option C is correct and relies on the dino instance variable for the outer class instance. Option D would be correct if Dino were changed to the correct class name, Dinosaur. Finally, option F is correct and relies on the fact that roar() is an instance method, which means there's an implicit instance of the outer class Dinosaur available. The Dinosaur. prefix is optional, though."
    },
    {
      "number": 13,
      "answers": [
        "C"
      ],
      "explanation": " Both objects are instances of the class Laptop. This means the overridden startup() method in the Laptop class gets called both times thanks to polymorphism, making option C correct."
    },
    {
      "number": 14,
      "answers": [
        "E"
      ],
      "explanation": " The static initializer is only run once, so faster is printed exactly once. The drive() method is called twice, printing two lines each. Therefore, the program prints five lines, and option E is correct."
    },
    {
      "number": 15,
      "answers": [
        "B",
        "D",
        "F"
      ],
      "explanation": " Option A is incorrect as methods cannot be marked final within an interface. Interfaces support static methods that are marked public or private, making options B and D correct and option E incorrect. Option F is correct and the lack of an access modifier makes the method implicitly public, not package, making option C incorrect."
    },
    {
      "number": 16,
      "answers": [
        "A"
      ],
      "explanation": " While the permits clause is optional for sealed classes with subclasses in the same file, the extends clause in each subclass is not. For this reason, Mercury, Venus, and Earth do not compile. Mars also does not compile. When the permits clause is specified, all subclasses must be listed. For this reason, option A is correct."
    },
    {
      "number": 17,
      "answers": [
        "E"
      ],
      "explanation": " The first woof() method does not compile because bark is a primitive, not an object, and does not have a toString() method. The main() method also does not compile because it is static and all of the woof() methods require an instance of Canine. Since these two lines do not compile, option E is the correct answer."
    },
    {
      "number": 18,
      "answers": [
        "C"
      ],
      "explanation": " A local variable is effectively final when its primitive value or object reference does not change after it is initialized, making option C the correct answer. Note that option D is incorrect because any change to the variable after it is initialized disqualifies it for being considered effectively final."
    },
    {
      "number": 19,
      "answers": [
        "C"
      ],
      "explanation": " The sell() method is declared final in the Vegetable class. The Turnip class then attempts to override this method, resulting in a compilation error and making option C the correct answer."
    },
    {
      "number": 20,
      "answers": [
        "D"
      ],
      "explanation": " The case statements incorrectly use the enum name as well as the value, such as DaysOff.ValentinesDay. Since the type of the enum is determined by the value of the variable in the switch statement, the enum name is not allowed and causes a compilation error when used. For this reason, option D is correct."
    },
    {
      "number": 21,
      "answers": [
        "D"
      ],
      "explanation": " Records are implicitly final and cannot be extended. For this reason, the Panda declaration does not compile. Setting a value on this.name is not permitted in a compact constructor, although the constructor parameter name may be reassigned. The rest of the code compiles without issue. Since two lines don't compile, option D is correct."
    },
    {
      "number": 22,
      "answers": [
        "B",
        "E"
      ],
      "explanation": " There is no that keyword, so options A and D are incorrect. Option B is correct, as this can access all members declared within the class. Option C is incorrect, as only inherited members can be accessed. For example, private members declared in a parent class cannot be accessed using super. Option E is correct, as this allows access to members declared in the class and those inherited from a parent. Finally, option F is incorrect, as static methods do not have access to this or super references."
    },
    {
      "number": 23,
      "answers": [
        "D"
      ],
      "explanation": " A class can implement an interface, not extend it, ruling out options A, B, and C. Classes do extend an abstract class, ruling out option F. Finally, an interface can only extend another interface, making option D the correct answer."
    },
    {
      "number": 24,
      "answers": [
        "B"
      ],
      "explanation": " Three instances of Chicken are created on lines 8–10. On line 11, the value of eggs in the first two instances is set to 2, while the third instance has a value of 3. On line 12, the original instance that was pointed to by c2 (with an eggs value of 2) is dereferenced and eligible for garbage collection. The c1 and c2 variables now both point to the same instance with an egg value of 2. Finally, on line 13, the eggs value for c3 is changed from 3 to null. For this reason, option B is correct."
    },
    {
      "number": 25,
      "answers": [
        "C"
      ],
      "explanation": " Java does not allow multiple inheritance, so having one class implement two interfaces that both define the same default method signature leads to a compiler error, unless the class overrides the method. In this case, the talk(String…) method defined in the Performance class is an overloaded method, not an overridden one, because the signatures do not match. Therefore, the Performance class does not compile, making option C correct."
    },
    {
      "number": 26,
      "answers": [
        "B"
      ],
      "explanation": " First off, Pump is not a functional interface. The toString() method will be overridden by any class inheriting the interface (via lang.lang.Object), so it does not count as an abstract method. On the other hand, Bend is a functional interface and contains one abstract method. The code compiles and prints 5.0 bent! at runtime, making option B correct. Using an instance variable to call a static method, r.apply() in the main() method, is permitted but discouraged."
    },
    {
      "number": 27,
      "answers": [
        "B"
      ],
      "explanation": " If the variables are public, the class is not encapsulated because callers have direct access to them. This rules out options C and D. Having private methods doesn't allow the callers to use the data, making option A an undesirable answer. Option B is correct and the classic definition of encapsulation where the data is not exposed directly. Option E is close, but the question asks for the broadest access allowed."
    },
    {
      "number": 28,
      "answers": [
        "B"
      ],
      "explanation": " Option B is correct because mutability means the state can change, and immutability means it cannot. The other options are invalid. In option C, rigidity is not a common programming term."
    },
    {
      "number": 29,
      "answers": [
        "C"
      ],
      "explanation": " The stroke() method is static, which means it cannot access the instance method breath() on line k2, making option C correct."
    },
    {
      "number": 30,
      "answers": [
        "D"
      ],
      "explanation": " The Hammer class is a subclass of the Tool class. The repair() method can be declared in the Hammer subclass with a different return type because the parent method is not inherited. For these reasons, options A and C are incorrect. On the other hand, the use() method has package-level access in Tool, with the overridden version in Hammer reducing the visibility to private. This is an invalid override, making option D correct. The rest of the lines compile without issue."
    },
    {
      "number": 31,
      "answers": [
        "F"
      ],
      "explanation": " Methods cannot be both abstract and final, making option A incorrect. Abstract interface methods are always public, making option C incorrect. Finally, options B, D, and E list modifiers that can't be applied to methods. Therefore, option F is the answer."
    },
    {
      "number": 32,
      "answers": [
        "A"
      ],
      "explanation": " While both objects are instances of Bush, we are not calling methods in this example. Virtual method invocation works only for methods, not instance variables. For instance variables, Java looks at the type of the reference and calls the appropriate variable based on the reference. Based on the reference types of the three variables (Plant, Bush, Plant), option A is correct."
    },
    {
      "number": 33,
      "answers": [
        "G"
      ],
      "explanation": " The code compiles, so options E and F are incorrect. Remember that the permits clause is optional if the sealed subclasses are in the same file. Given the class declaration, exactly four subclasses inherit from Organ. The Stomach class is non-sealed, though, which means the larger program could define additional classes in the same package that extend Stomach and inherit Organ. For this reason, option G is correct."
    },
    {
      "number": 34,
      "answers": [
        "D"
      ],
      "explanation": " Java classes are defined in this order: package statement, import statements, class declaration. That makes option D the only correct answer. Note that not all of these statements are required. For example, a class may not have a package statement, but if it does, it must come first in the file."
    },
    {
      "number": 35,
      "answers": [
        "A",
        "D",
        "F"
      ],
      "explanation": " The code does compile as is, making option A correct. Removing private on line 2 would not cause a compiler error in the main() method, making option D correct. Option F is the final correct answer because a static type such as an enum can be defined in both inner and static nested classes."
    },
    {
      "number": 36,
      "answers": [
        "B",
        "F"
      ],
      "explanation": " A static method can access static variables, but not instance variables. The getNumRakes() method does not compile, so option B is correct. The main() method calls the constructor, which outputs a. Then the main method calls the run() method. The run() method calls the constructor again, which outputs a again. Next, the run() method calls the Sand() method, which happens to have the same name as the constructor. This outputs b. Therefore, option F is correct."
    },
    {
      "number": 37,
      "answers": [
        "C"
      ],
      "explanation": " While an anonymous class can extend another class or implement an interface, it cannot be declared abstract since it has no class name. For this reason, option C is correct. The other classes may be declared abstract since they have a class name."
    },
    {
      "number": 38,
      "answers": [
        "C",
        "E",
        "F"
      ],
      "explanation": " The public access modifier is the broadest, making options E and F correct. Package access limits references to those in the same package. The protected access modifier adds on subclass access, making option C correct."
    },
    {
      "number": 39,
      "answers": [
        "C"
      ],
      "explanation": " Java does not allow multiple variables to be declared in the same statement using a local variable type inference. Lines x3 and x4 both have compiler errors. Since the question asks about the first line with a compiler error, option C is the answer."
    },
    {
      "number": 40,
      "answers": [
        "E"
      ],
      "explanation": " All four members of the Telephone interface are implicitly public, making option E correct. Only private and private static interface methods are not public, and they must be explicitly marked private."
    },
    {
      "number": 41,
      "answers": [
        "C"
      ],
      "explanation": " The new keyword is used to call the constructor for a class and instantiate an instance of the class, making option C correct. A primitive cannot be created using the new keyword, so option B is incorrect. Dealing with references happens after the object created by new is returned. The other options are invalid."
    },
    {
      "number": 42,
      "answers": [
        "B"
      ],
      "explanation": " From within a method, an array or varargs parameter is treated the same. However, there is a difference from the caller's point of view. A varargs parameter can receive either an array or individual values, making lines 19 and 20 compile. However, an array parameter can take only an array, which permits line 23 but prevents line 22 from compiling. Both lines 21 and 24 compile because null can be passed to a method taking an array or a vararg parameter. Since there is only one line that doesn't compile, option B is the answer."
    },
    {
      "number": 43,
      "answers": [
        "E"
      ],
      "explanation": "By definition, you cannot change the value of an instance variable in an immutable class. There are no setter methods, making option A incorrect. While option B would allow you to set the value, the class would no longer be immutable. Option C is incorrect because that would not modify the original instance. Option E is correct. If you are an advanced developer, you might know that you can use reflection to change the value. Don't read into questions like this on the exam. Reflection isn't on the exam, so you can pretend it doesn't exist."
    },
    {
      "number": 44,
      "answers": [
        "E"
      ],
      "explanation": "This code is already a functional interface and compiles without any changes, making option E correct. The Play interface has a single abstract method: fun(). The other methods have a method body, which shows they are not abstract."
    },
    {
      "number": 45,
      "answers": [
        "F"
      ],
      "explanation": "Both of these descriptions refer to variable and static method hiding, respectively, making option F correct. Only instance methods can be overridden, making options A and B incorrect. Options C, D, and E are also incorrect because replacing and masking are not real terms in this context."
    },
    {
      "number": 46,
      "answers": [
        "C",
        "D"
      ],
      "explanation": "Records can be declared with any access modifier and included as nested classes, making option A incorrect. A record cannot extend other classes, but it can implement interfaces, making option B incorrect and option C correct. A record can contain multiple constructors, but at most one compact constructor since a compact constructor does not take any arguments. For this reason, option D is correct and option E is incorrect. Finally, option F is incorrect. A developer could define a record with a mutable field such as an ArrayList and accidentally expose it for direct modification."
    },
    {
      "number": 47,
      "answers": [
        "F"
      ],
      "explanation": "This class is a good example of encapsulation. It has a private instance variable and is accessed by a public method. No changes are needed to encapsulate it, and option F is correct."
    },
    {
      "number": 48,
      "answers": [
        "F"
      ],
      "explanation": "The declarations of the local classes Robot and Transformer compile without issue. The only compilation problem in this program is the last line of the main() method. The variable name is defined inside the local class and not accessible outside class declaration without a reference to the local class. Due to scope, this last line of the main() method does not compile, making option F the correct answer. Note that the first part of the print() statement in the main() method, if the code compiled, prints GiantRobot."
    },
    {
      "number": 49,
      "answers": [
        "C"
      ],
      "explanation": "The Bottle class includes a static nested class Ship that must be instantiated in a static manner. Line w2 uses an instance of Bottle to instantiate the Ship. Therefore, line w2 does not compile, and option C is the correct answer."
    },
    {
      "number": 50,
      "answers": [
        "E"
      ],
      "explanation": "The instance variables, constructor, instance and static initializers, and method declarations can appear in any order within a class declaration, making option E correct."
    },
    {
      "number": 51,
      "answers": [
        "A"
      ],
      "explanation": "Remember that the default initialization of a boolean instance variable is false, so outside is false at line p1. Therefore, this(4) will cause rope to be set to 5, while this(5) will cause rope to be set to 6. Since 5 is the number we are looking for, option A is correct, and option C is incorrect. Option B is also incorrect. While the statement does create a new instance of Jump, with rope having a value of 5, that instance is nested, and the value of rope does not affect the surrounding instance of Jump that the constructor was called in. Option D is also incorrect. The value assigned to rope is 4, not the target 5. Options E and F do not compile because the superclass is Object, which does not have a constructor taking an int."
    },
    {
      "number": 52,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "Option A is true because encapsulation improves security because instance variables cannot be accessed directly. Implementing encapsulation prevents internal attributes of a class from being modified directly, so option D is a true statement. By preventing access to internal attributes, we can also maintain class data integrity between elements, making option C a true statement. Option F is also a true statement about encapsulation, since well-encapsulated classes are often easier to use. Encapsulation makes no guarantees about performance and concurrency, making option B one of the answers. Option E is the other answer because it describes immutability, not encapsulation."
    },
    {
      "number": 53,
      "answers": [
        "C"
      ],
      "explanation": "Option A is allowed because the turnOn() method is public and can be called from anywhere. Options B and D are allowed since the method is in the same class, which is always allowed! Option E is allowed because Tent and Blanket are in the same package. The Phone class cannot access the wash() method in the Blanket class because it is in a different package, making option C correct."
    },
    {
      "number": 54,
      "answers": [
        "C"
      ],
      "explanation": "The display() method has protected access. This means it can be accessed by instance methods in the same package and any subclasses. There are no subclasses in this example, so we only need to count the classes in the same package. Option C is correct because Flashlight and Phone are in the package."
    },
    {
      "number": 55,
      "answers": [
        "B",
        "D"
      ],
      "explanation": "While Java does not allow a class to extend more than one class, it does allow a class to implement any number of interfaces. Multiple inheritance is, therefore, only allowed via interfaces, making option B correct. Interfaces can extend other interfaces, making option D the other correct answer. The other statements are incorrect."
    },
    {
      "number": 56,
      "answers": [
        "B",
        "D",
        "E"
      ],
      "explanation": "Immutable objects are ones that are not modified after they are created. Immutable objects can have public constructors. There is no need to change the access modifier to private, making option A incorrect. All instance variables should be private in an immutable class to prevent subclasses and classes within the package from modifying them outside the class, making option B correct and option C incorrect. They should not have any setter methods, making option D correct. The class should also either be marked final or contain final methods to prevent subclasses from altering the behavior of the class, making option E correct. Finally, option F is incorrect as String is immutable, so a defensive copy is not required. Note that if species were a mutable type, like List, a defensive copy would be required."
    },
    {
      "number": 57,
      "answers": [
        "E"
      ],
      "explanation": "The main() method attempts to define an anonymous class instance but fails to provide the class or interface name, or use the new keyword. The right-hand side of the assignment to the seaTurtle variable should start with new CanSwim(). For this reason, option E is the correct answer. If the code were corrected with the proper declaration, then the program would output 7 at runtime."
    },
    {
      "number": 58,
      "answers": [
        "E"
      ],
      "explanation": "The Puppy class does not declare a constructor, so the default no-argument constructor is automatically inserted by the compiler. What looks like a constructor in the class is actually a method that has a return type of void. Therefore, the line in the main() method to create the new Puppy(2) object does not compile, since there is no constructor capable of taking an int value, making option E the correct answer."
    },
    {
      "number": 59,
      "answers": [
        "B"
      ],
      "explanation": "The method signature has package, or default, access; therefore, it is accessible to classes in the same package, making option B the correct answer."
    },
    {
      "number": 60,
      "answers": [
        "D"
      ],
      "explanation": "First, both CanBurrow and HasHardShell compile as functional interfaces since they contain exactly one abstract method, although only the latter uses the optional @FunctionalInterface annotation. The declarations of these two interfaces, along with the abstract class Tortoise, compile without issue, making options A, B, and C incorrect. The class DesertTortoise inherits two abstract methods, one from the interface CanBurrow and the other from the abstract parent class Tortoise. Since the class implements only one of them and the class is concrete, the class declaration of DesertTortoise fails to compile, making option D the correct answer."
    },
    {
      "number": 61,
      "answers": [
        "C"
      ],
      "explanation": "The interface declarations compile without issue. When inheriting two default methods with the same signature, the Tower class is required to override both methods even if the class is marked abstract. For this reason, line m3 is the first line that does not compile, and option C is correct. Note that there is no possible overridden method that can fulfill both inherited default methods since the return types are not covariant."
    },
    {
      "number": 62,
      "answers": [
        "F"
      ],
      "explanation": "The height variable is declared within the if statement block. Therefore, it cannot be referenced outside the if statement, and the code does not compile, making option F correct. The rest of the code is correct."
    },
    {
      "number": 63,
      "answers": [
        "A",
        "E",
        "F"
      ],
      "explanation": "Java supports three types of comments: single-line (//), multiline (/* */), and Javadoc (/** **/), making options A, E, and F correct. The other options may be comments in other languages, but not in Java."
    },
    {
      "number": 64,
      "answers": [
        "A",
        "C",
        "F"
      ],
      "explanation": "An abstract method is one that will be implemented by a subclass. For this reason, it cannot be combined with final or private, as both prevent a method from being overridden, making options B and D incorrect. An abstract method can also not be marked static, since static members belong to the class level, not an instance, making option E incorrect. Options A, C, and F are the correct answers. Note that marking a private method final has no practical implication, although it is allowed."
    },
    {
      "number": 65,
      "answers": [
        "F"
      ],
      "explanation": "The class data, stuff, is declared public, allowing any class to modify the stuff variable and making the implementation inherently unsafe for encapsulation. Therefore, there are no values that can be placed in the two blanks to ensure the class properly encapsulates its data, making option F correct. Note that if stuff were declared private, options A, B, C, and D would all be correct. Encapsulation does not require any specific method names, just that the internal attributes are protected from outside access, which all of these sets of values do achieve. Option E is incorrect because classes cannot define default methods."
    },
    {
      "number": 66,
      "answers": [
        "C"
      ],
      "explanation": "The second row is incorrect, as private methods belong to an instance, not the class. The fourth row is also incorrect, as default methods require a method body. The rest of the rows are correct, making option C correct."
    },
    {
      "number": 67,
      "answers": [
        "D"
      ],
      "explanation": "The super() statement is used to call a constructor in the parent class, while super is used to reference a member of the parent class. The this() statement is used to call a constructor in the current class, while this is used to reference a member of the current class. For these reasons, option D is the correct answer."
    },
    {
      "number": 68,
      "answers": [
        "F"
      ],
      "explanation": "A sealed class can only be extended by a class with a final, non-sealed, or sealed modifier, making option F correct. The permits clause is optional if the subclasses are within the same file. Option A is incorrect because nonsealed is not a keyword. Options B and C are incorrect because they are missing one of the required modifiers. Options D and E are incorrect because records and interfaces cannot extend a class."
    },
    {
      "number": 69,
      "answers": [
        "B"
      ],
      "explanation": "Line 14 calls the method on line 8 since it is a Watch object. That returns watch, making option A incorrect. Line 15 calls the method on line 3 since it is a SmartWatch object and the method is properly overridden. That returns smart watch, so option B is the answer, and option C is incorrect."
    },
    {
      "number": 70,
      "answers": [
        "F"
      ],
      "explanation": "The Cinema class defines a constructor that takes a String value, which means the compiler does not insert the default no-argument constructor. Therefore, it is not available in the Movie constructor, and an explicit constructor must be called with super(). Since this is not done, the Movie constructor does not compile, making option F the correct answer."
    },
    {
      "number": 71,
      "answers": [
        "D"
      ],
      "explanation": "This class does not implement Serializable, so option A is incorrect. This code is well encapsulated because the instance variables are private. The algae and wave variables are immutable because they are marked final and there are no methods that can change them. The getAlgae() method creates a defensive copy, preventing direct access to the algae object. Finally, the sun variable is initialized to 0 and cannot be changed after its creation. The setSun() method is missing a this reference, so the assignment sun = sun assigns the method parameter sun to itself. For these reasons, the class is immutable, and option D is correct."
    },
    {
      "number": 72,
      "answers": [
        "E"
      ],
      "explanation": "Local variable type inference requires a value so that the type can be inferred. The var color; statement without a value is not allowed, making option E the answer."
    },
    {
      "number": 73,
      "answers": [
        "A"
      ],
      "explanation": "If the program is called with a single input south, then south would be printed at runtime. If the program is called with no input, then the compass array would be of size zero and an ArrayIndexOutOfBoundsException would be thrown at runtime. Finally, if the program is called with a string that does not match one of the values in Direction, then an IllegalArgumentException would be thrown at runtime. The only result not possible is WEST, since the enum value is in lowercase, making option A the correct answer."
    },
    {
      "number": 74,
      "answers": [
        "C"
      ],
      "explanation": "A class cannot contain two methods with the same method signature, even if one is static and the other is not. Therefore, the code does not compile because the two declarations of playMusic() conflict with one another, making option C the correct answer."
    },
    {
      "number": 75,
      "answers": [
        "A",
        "E",
        "F"
      ],
      "explanation": "First, the return types of an overridden method must be covariant, making option A correct. They can be the same, but it is not required, making option C incorrect. Next, the access modifier must be the same as or broader than the child method, making option B incorrect, and option F correct. Option D is incorrect as an overridden method is not required to throw a checked exception declared in the parent version of the method. If it does declare a checked exception, it cannot be new or broader than the ones declared in the superclass, making option E correct."
    },
    {
      "number": 76,
      "answers": [
        "D"
      ],
      "explanation": "A private non-static interface method may only be accessed from other private or default methods declared within the interface. Lines 15 and 21 do not compile because the private method is called within static methods. Line 26 does not compile because a private interface method cannot be called in a method outside the interface declaration. Since these three lines do not compile, option D is correct."
    },
    {
      "number": 77,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles without issue. Line 2 declares an overloaded constructor, while line 5 declares a compact constructor. Line 8 creates a new method. The beats value can then be accessed from getBeats() or beats(), the latter of which is provided by the compiler. When the code runs, the compact constructor is called and the input parameter is replaced with 10, making option A correct."
    },
    {
      "number": 78,
      "answers": [
        "B",
        "D",
        "E"
      ],
      "explanation": "Interface variables are implicitly public, static, and final, making options B, D, and E correct. The words const and constant aren't modifiers, so options A and F are incorrect. Option C is also incorrect. Variables cannot be declared as abstract in interfaces, nor in classes."
    },
    {
      "number": 79,
      "answers": [
        "B"
      ],
      "explanation": "Integer is the name of a class in Java. While it is bad practice to use the name of a class as your local variable name, it is legal. Therefore, k1 does compile. It is not legal to use a reserved word as a variable name. All of the primitives including int are reserved words. Therefore, k2 does not compile, and option B is the answer. Lines k4 and k5 don't compile either, but the question asks about the first line to not compile."
    },
    {
      "number": 80,
      "answers": [
        "C"
      ],
      "explanation": "The code compiles and runs without issue, so options A and B are incorrect. The question relies on your ability to understand variable scope. The today variable has local scope to the method in which it is executed. The tomorrow variable is re-declared in the method, but the reference used on line y is to the instance variable with a value of 10. Finally, the yesterday variable is static. While using an instance reference to access a static variable is not recommended, it does not prevent the variable from being read. The result is line y evaluates and prints 31 (20 + 10 + 1), making option C the correct answer."
    },
    {
      "number": 81,
      "answers": [
        "E"
      ],
      "explanation": "If an enum contains anything other than a list of values, then a semicolon (;) must follow the list of values. The Snow enum includes a method, so there must be a semicolon after the last value, FLURRY. For this reason, the code does not compile, and option E is correct. If the semicolon was added, then the code would compile and print 0 Sunny at runtime, with the overridden toString() replacing the default value of FLURRY."
    },
    {
      "number": 82,
      "answers": [
        "A"
      ],
      "explanation": "Option A is the correct answer because the first line of a constructor could be this() or super(), making it an invalid statement. Option B is a true statement because the compiler will insert the default no-argument constructor if one is not defined. Option C is also a true statement, since zero or more arguments may be passed to the parent constructor, if the parent class defines such constructors. Option D is also true. The value of a final instance variable must be set when it is declared in an initialization block or in a constructor."
    },
    {
      "number": 83,
      "answers": [
        "E"
      ],
      "explanation": "If only the com.mammal class needed access, option A would be correct. Access modifiers cannot be used to grant access to a list of packages. The Java Platform Module Framework can do this, but it is not an option in this question. Therefore, option E is correct."
    },
    {
      "number": 84,
      "answers": [
        "B"
      ],
      "explanation": "The super.getWeight() method returns 3 from the variable in the parent class, as polymorphism and overriding do not apply to instance variables. The this.height call returns the value of the variable in the current class, which is 4. For these reasons, option B is correct."
    },
    {
      "number": 85,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "The key here is understanding which of these features of Java allow one developer to build their application around another developer's code, even if that code is not ready yet. For this problem, an interface is the best choice. If the two teams agree on a common interface, one developer can write code that uses the interface, while another developer writes code that implements the interface. Assuming neither team changes the interface, the code can be easily integrated once both teams are done. For these reasons, option B is correct. Interfaces expose methods using the public keyword, making option E the other answer."
    },
    {
      "number": 86,
      "answers": [
        "F"
      ],
      "explanation": "The code compiles, even if the blank is replaced with a constant value, making option E incorrect. Note that the class correctly overrides both inherited default methods. While it is possible to call a specific inherited default method, even when it has been overridden, it requires calling super, which is not accessible from the static method main(). For these reasons, options A, B, C, and D do not work either, making option F correct."
    },
    {
      "number": 87,
      "answers": [
        "B"
      ],
      "explanation": "An enum declaration itself cannot be marked abstract, nor can any of its values, but its methods can be marked abstract, making option B the correct answer. Note that if an enum contains an abstract method, then every enum value must include an override of this abstract method."
    },
    {
      "number": 88,
      "answers": [
        "C"
      ],
      "explanation": "The static initializer is run only once. The static method is run twice since it is called twice. Therefore, three lines are printed, and option C is correct. The instance initializer block is never run because the Cars class is never constructed."
    },
    {
      "number": 89,
      "answers": [
        "D"
      ],
      "explanation": "An accessor (or getter) in a record is defined without a get prefix. For this reason, the declaration of getFirstName() is invalid because it includes an @Override annotation and there is no such method inherited. Since the code does not compile, option D is correct. For the exam, you don't need to know how to create annotations but you need to know when the common ones are incorrectly used. If the annotation were removed, then the code would print null at runtime."
    },
    {
      "number": 90,
      "answers": [
        "C"
      ],
      "explanation": "Dot notation is used for both reading and writing instance variables, assuming they are in scope. It cannot be used for referencing local variables, making option C the correct answer. It is possible that bar is a static variable, although accessing it in this manner is not recommended."
    },
    {
      "number": 91,
      "answers": [
        "A",
        "D",
        "E"
      ],
      "explanation": "The reference type of unknownBunny must be Bunny or a supertype of Bunny, including any abstract classes, concrete classes, or interfaces that Bunny inherits. For this reason, options A and E are correct, and option C is incorrect. Option B is incorrect. Since it already points to an instance of Bunny, casting it to a Bunny reference is allowed. Option D is trivially true. If the reference types of both are the same, then they can call the same instance members. Option F is incorrect, as casting is required to access members declared in Bunny that are not defined in Object."
    },
    {
      "number": 92,
      "answers": [
        "C",
        "E"
      ],
      "explanation": "Methods marked private or static are never inherited, so options A, B, and D are incorrect. Interface methods cannot be final, so option F is incorrect. That leaves default and abstract methods, which are both inherited by classes implementing the interface, making options C and E correct."
    },
    {
      "number": 93,
      "answers": [
        "C"
      ],
      "explanation": "The code does compile, so option E is incorrect. A functional interface is required to have exactly one abstract method. In both interfaces, that is roar(). The toString() and hashCode() method signatures match those from Object. Since they are provided to all subclasses, they are not considered abstract. Since roar() is the only abstract method, both are functional interfaces, making option C the answer."
    },
    {
      "number": 94,
      "answers": [
        "C",
        "E"
      ],
      "explanation": "To call a constructor, you must use the new keyword, making option E correct. It cannot be called as if it was a normal method. This rules out options A and B. Further, option D is incorrect because the parentheses are required. Option C is correct, as var may be used as a variable name."
    },
    {
      "number": 95,
      "answers": [
        "B"
      ],
      "explanation": "To a call an instance method, you can use the this prefix. The class name is not included, ruling out the last three methods. A method may contain at most one varargs parameter, and it must appear as the last argument in the list. For this reason, the sing_do() method is the only method using varargs that compiles. The sing() method also compiles but the question asked for the public methods. Therefore, option B is the answer."
    },
    {
      "number": 96,
      "answers": [
        "B"
      ],
      "explanation": "The code compiles without issue. The first print() statement refers to level declared in the Deeper class, so 5 is printed. The second and third print() statements actually refer to the same value in the Deep class, so 2 is printed twice. The prefix Matrix. is unnecessary in the first of the two print() statements and does not change the result. For these reasons, option B is the correct answer."
    },
    {
      "number": 97,
      "answers": [
        "D"
      ],
      "explanation": "A sealed subclass must have a final, sealed, or non-sealed modifier. For this reason, Second compiles. A record is implicitly final, so Hour also compiles. Micro compiles since it extends a non-sealed class. Minute is the only one that does not compile since an interface is implicitly abstract and is missing sealed or non-sealed, making option D correct."
    },
    {
      "number": 98,
      "answers": [
        "A"
      ],
      "explanation": "The play() method is overridden in Violin for both MusicCreator and StringInstrument, so the return type must be covariant with both. Long is a subclass of Number, and therefore, it is covariant with the version in MusicCreator. Since it matches the type in StringInstrument, it can be inserted into the blank, and the code would compile. Integer is not a subclass of Long used in StringInstrument and would cause the code to not compile. Number is compatible with the version of the method in MusicCreator but not with the version in StringInstrument. For these reasons, Long is the only class that allows the code to compile, making option A the correct answer."
    },
    {
      "number": 99,
      "answers": [
        "E"
      ],
      "explanation": "The IsoRightTriangle class is abstract; therefore, it cannot be instantiated on line g3, making option E correct. If the abstract modifier were removed from the IsoRightTraingle declaration, then the rest of the code would compile and print irt at runtime."
    },
    {
      "number": 100,
      "answers": [
        "F"
      ],
      "explanation": "The private static method wagTail() attempts to access an instance-based default method chaseTail(), which results in a compiler error, making option F correct. While buryBone() is not used, it does not result in a compiler error, making option D incorrect. Overridden methods are permitted to declare new unchecked exceptions, and since IllegalArgumentException is unchecked, the override is allowed, making option E incorrect."
    },
    {
      "number": 101,
      "answers": [
        "E"
      ],
      "explanation": "While you can suggest to the JVM that it might want to run a garbage collection cycle, the JVM is free to ignore your suggestion. Option B is how to make this suggestion. Since garbage collection is not guaranteed to run, option E is correct."
    },
    {
      "number": 102,
      "answers": [
        "D"
      ],
      "explanation": "The access modifier of strength is protected, meaning subclasses and classes within the same package can modify it. Changing the value to private would improve encapsulation by making the Protect class the only one capable of directly modifying it. For these reasons, option D is correct."
    },
    {
      "number": 103,
      "answers": [
        "A",
        "D"
      ],
      "explanation": "A lambda can reference any instance variable, static variable, or lambda parameter that is in scope, making option A correct. Lambdas require local variables and method parameters to be effectively final in order to use them, making option D the other correct answer."
    },
    {
      "number": 104,
      "answers": [
        "B"
      ],
      "explanation": "An immutable class must not allow the state to change. In the Faucet class, the caller has a reference to the List being passed in and can change the size or elements in it. Similarly, any class with a reference to the object can get the List by calling getPipes() and make these changes. The Faucet class is not immutable. The Spout class shows how to fix these problems and is immutable, making option B correct."
    },
    {
      "number": 105,
      "answers": [
        "A",
        "C",
        "E"
      ],
      "explanation": "Option A is correct and returns true since Coral inherits Friendly from its superclass Animal. Option B is false, as using null with the instanceof operator always returns false. Options C and E are both correct and return true because all classes inherit Object, even those that don't explicitly extend it. Option D is false because Fish does not inherit the Friendly interface. Finally, option F does not compile, as Dolphin is abstract and cannot be instantiated directly."
    },
    {
      "number": 106,
      "answers": [
        "B"
      ],
      "explanation": "While it is not recommended to change the value of an enum after it is created, it is legal. Each enum value has its own copy of numDays. This means the setter changes it for CHICKEN, but not for PENGUIN. Therefore, option B is correct. Both calls on CHICKEN print the updated value of 20, while PENGUIN retains the original 75."
    },
    {
      "number": 107,
      "answers": [
        "B"
      ],
      "explanation": "Line 3 does not compile, as a method with a body within an interface must be explicitly marked static, default, or private, making option B correct. The rest of the lines compile without issue."
    },
    {
      "number": 108,
      "answers": [
        "E"
      ],
      "explanation": "The type of the variable in the switch statement is the enum Currency, but the case statements use int values. While the enum class hierarchy does support an ordinal() method, which returns an int value, the enum values cannot be compared directly with int values. For this reason, the Bank class does not compile, making option E the correct answer."
    },
    {
      "number": 109,
      "answers": [
        "B",
        "G"
      ],
      "explanation": "A record can contain many of the same members as a class, such as static initializers, static methods, nested classes, and constructors. Instance variables and initializers cannot be declared inside a record, as this could break immutability, making options B and G correct. Option A is incorrect, as provided methods, such as hashCode() or toString(), may be overridden in the record declaration."
    },
    {
      "number": 110,
      "answers": [
        "A"
      ],
      "explanation": "The f in 4.0f means the type is a float, making option A correct. Local variable type inference chooses an exact match rather than using autoboxing to choose Float. Note that option D does not compile, as the compiler won't perform a numeric promotion to double and then autobox to Double at the same time."
    },
    {
      "number": 111,
      "answers": [
        "B"
      ],
      "explanation": "A class can trivially be assigned to a superclass reference variable but requires an explicit cast to be assigned to a subclass reference variable. For these reasons, option B is correct."
    },
    {
      "number": 112,
      "answers": [
        "D"
      ],
      "explanation": "A functional interface may have any number of static, default, private static, or private methods. It can have only one qualified abstract method, though, making option D correct."
    },
    {
      "number": 113,
      "answers": [
        "D"
      ],
      "explanation": "This class has poor encapsulation since the age variable is public. This means that a developer could modify the body of main() to change the value of mandrill.age to any integer value, making option D correct."
    },
    {
      "number": 114,
      "answers": [
        "C"
      ],
      "explanation": "All three references point to the String object lion by the end of the main() method. This makes the other two String objects eligible for garbage collection and makes option C correct."
    },
    {
      "number": 115,
      "answers": [
        "B",
        "F"
      ],
      "explanation": "A functional interface has exactly one abstract method. This includes inherited methods. If Panther has a single abstract method, Cub is a functional interface if it does not add any more abstract methods. This matches option B. However, if Panther has two abstract methods, there is no code in Cub that can make it a functional interface, and option F is the other answer."
    },
    {
      "number": 116,
      "answers": [
        "B"
      ],
      "explanation": "When the main() method instantiates the object, line 2 first runs and sets the variable using the declaration. Then the instance initializer on line 6 runs. Finally, the constructor runs. Since the constructor is the last of the three to run, that is the value set when we print the result, so option B is correct."
    },
    {
      "number": 117,
      "answers": [
        "C"
      ],
      "explanation": "An abstract method cannot define a body, meaning the declaration of getNumberOfRings() is invalid and option C is correct. The rest of the code compiles without issue. While the compiler will prevent cycles within overloaded constructors, it does not do so for methods, meaning option F is incorrect."
    },
    {
      "number": 118,
      "answers": [
        "B",
        "F"
      ],
      "explanation": "The type is determined based on the value at initialization. It can be null at this point, but only if type information is provided such as (String)null. It can be assigned null later, making option B correct. Both primitives and objects can be used with var, making option F correct."
    },
    {
      "number": 119,
      "answers": [
        "A"
      ],
      "explanation": "The protected modifier allows access by any subclass or class that is in the same package; therefore, option A is the correct answer."
    },
    {
      "number": 120,
      "answers": [
        "C"
      ],
      "explanation": "The main() method defines a local class Oak that correctly extends Tree, a static nested class. The method getWater() is not permitted to read the local variable water, though, since it is not final or effectively final, making option C correct. If the last line of the method were removed, then the program would compile and print 8."
    },
    {
      "number": 121,
      "answers": [
        "B",
        "D"
      ],
      "explanation": "A class can implement multiple interfaces, making option B correct. An interface can also extend multiple interfaces, making option D correct as well."
    },
    {
      "number": 122,
      "answers": [
        "D"
      ],
      "explanation": "The method looks like a setter or mutator method. However, it is incorrectly implemented since the method is missing a this reference and doesn't actually change the value. Therefore, option D is correct."
    },
    {
      "number": 123,
      "answers": [
        "A",
        "C",
        "F"
      ],
      "explanation": "Option A is correct and option B is incorrect because this() calls another constructor in the same class. Option C is correct because this() without parameters is the default constructor and is not inserted automatically by the compiler if another constructor is present. Options D and E are both incorrect because only one of super() or this() can be used from the same constructor. Finally, option F is correct, as super() or this() must come first in a constructor."
    },
    {
      "number": 124,
      "answers": [
        "E"
      ],
      "explanation": "The code compiles and runs without issue, so option A is incorrect. The question involves understanding the value and scope of each variable at the print() statement. The variables feet and tracks are locally scoped and set to 4 and 15, respectively, ignoring the value of tracks of 5 in the instance of the class. Finally, the static variable s.wheels has a value of 1. The result is that the combined value is 20, making option E the correct answer."
    },
    {
      "number": 125,
      "answers": [
        "C, F"
      ],
      "explanation": "Line m3 does not compile because isDanger() is an invalid method override. An overridden method may not throw a broader checked exception than it inherits. Since Exception is a superclass of Problem, the code does not compile, and option C is correct. Line m6 does not compile because the return type of isDanger() is void, which cannot be assigned to a variable, making option F also correct."
    },
    {
      "number": 126,
      "answers": [
        "C, E, F"
      ],
      "explanation": "Top-level classes can be set only with public and package access, making option A incorrect. On the other hand, member inner classes can be set with any of the four access levels, making option D incorrect. Both types of classes can be declared with a final or abstract modifier, making option B incorrect and option F correct. Both can also include constructors, making option C correct. Finally, option E is correct and one of the primary features of inner classes."
    },
    {
      "number": 127,
      "answers": [
        "A"
      ],
      "explanation": "Option A is the only correct answer, as a class declaration is the only required component in a Java class file. Note that we said a Java class file here; Java also allows interfaces, annotations, modules, records, and enums to be defined in a file. A class file may have a single package statement or any number of import statements. Neither is required."
    },
    {
      "number": 128,
      "answers": [
        "B"
      ],
      "explanation": "On line 9, all three objects have references. The elena and zoe objects have a direct reference. The janeice object is referenced through the elena object. On line 10, the reference to the janeice object is replaced by a reference to the zoe object. Therefore, the janeice object is eligible to be garbage collected, and option B is correct. Note that elena still holds the reference to the original zoe object."
    },
    {
      "number": 129,
      "answers": [
        "D"
      ],
      "explanation": "Both the Drive and Hover interfaces define a default method getSpeed() with the same signature but different return types. The Car class implements both interfaces, which means it inherits both default methods. Since the compiler does not know which one to choose, the Car class must override the default method. Since it does not, the code does not compile and option D is correct. Note that in this case it is not possible to write a method that inherits both default methods since the return values cannot be made covariant."
    },
    {
      "number": 130,
      "answers": [
        "C, D"
      ],
      "explanation": "On line 10, we are passing a float. Since there is no exact match, Java attempts to promote the primitive type to double before trying to wrap it as a Float, making option D correct. On line 11, the value 2 is first cast to a byte. It is then increased by one using the addition + operator. The addition + operator automatically promotes all byte and short values to int. Therefore, the value passed to choose() in the main() method is an int. The choose(int) method is called, returning 5 and making option C the other correct answer."
    },
    {
      "number": 131,
      "answers": [
        "D"
      ],
      "explanation": "Line 3 does not compile because printColor() is marked final and cannot be overridden. Line 5 does not compile because the toSpectrum() method is marked abstract and must be overridden by each enum value. Finally, line 6 does not compile because enum constructors are implicitly private. For these three reasons, option D is correct."
    },
    {
      "number": 132,
      "answers": [
        "E"
      ],
      "explanation": "The getEqualSides() method is not overridden on line x1, since it is private in the parent class and not inherited. For this reason, line x1 compiles. On the other hand, the override of getEqualSides() in Square is invalid. A static method cannot override a non-static method and vice versa. For this reason, option E is the correct answer. The rest of the lines compile without issue."
    },
    {
      "number": 133,
      "answers": [
        "A"
      ],
      "explanation": "Since only one package needs access and it is the same package the class is in, option A is correct. Using protected would permit access from other classes within the package, but allow subclasses in other packages to access it as well."
    },
    {
      "number": 134,
      "answers": [
        "D"
      ],
      "explanation": "A concrete class is not allowed to have abstract methods, but the other two types are. This makes the second row in the first column incorrect. All three types are allowed to have static final constants, making the whole second column correct. In the last column, there are two errors. An abstract class can have a constructor, but an interface cannot. Note that an abstract class cannot be instantiated. Instead, it requires a subclass. This gives us a total of three incorrect cells, making option D the answer."
    },
    {
      "number": 135,
      "answers": [
        "C, D, F"
      ],
      "explanation": "A class extending a sealed class must be declared final, sealed, or non-sealed, making option F correct. Option C and D are also correct, as a sealed or non-sealed subclass may also be marked with any access modifiers. The other modifiers are invalid or cannot be applied to a class declaration."
    },
    {
      "number": 136,
      "answers": [
        "B, C, E"
      ],
      "explanation": "A functional interface must have exactly one abstract method, which is option B. There are no restrictions on the number of private or static methods, which make options C and E also correct."
    },
    {
      "number": 137,
      "answers": [
        "C"
      ],
      "explanation": "The contents instance variable is marked final, which means it must be set as part of object initialization. Since it is not, the Gift class cannot be instantiated and the class does not compile. For this reason, option C is correct. The setContents() method also does not compile since a final instance object cannot be set in an instance method after the class has been initialized."
    },
    {
      "number": 138,
      "answers": [
        "D"
      ],
      "explanation": "Line 3 does not compile because the method is not marked default, static, or private. Line 7 does not compile because the return type is int, and the fly() method does not return a value. Line 9 does not compile because Bird is a final class and cannot be extended. For these reasons, option D is correct."
    },
    {
      "number": 139,
      "answers": [
        "D"
      ],
      "explanation": "This example deals with polymorphism since the methods are being called on the object instance. Since both objects are of type FlemishRabbit, HOP is printed twice, and option D is the correct answer."
    },
    {
      "number": 140,
      "answers": [
        "B, D, E"
      ],
      "explanation": "Underscores (_) are permitted in identifiers with the exception of a single underscore, making option A incorrect. Currency symbols, such as the dollar sign ($), are allowed, but no other symbols are allowed, making option C incorrect. Numbers are allowed, but not as the first character. Therefore, option F is incorrect. The rest of the options are valid class names, making the answer options B, D, and E correct. Note that class names begin with an uppercase letter by convention, but this is not a requirement."
    },
    {
      "number": 141,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles without issue. Java allows methods to be overridden, but not variables. Therefore, marking them final does not prevent them from being reimplemented in a subclass. Furthermore, polymorphism does not apply in the same way it would to methods as it does to variables. In particular, the reference type determines the version of the secret variable that is selected, making the output 2.0 and option A the correct answer."
    },
    {
      "number": 142,
      "answers": [
        "C"
      ],
      "explanation": "Java is a pass-by-value language, which means changes made to the name reference in the slalom() method are not passed back to main(). Therefore, myName stays as Rosie, allowing us to eliminate options B and D. Setting the racer object to null in the slalom() method doesn't change the mySkier reference in main(), allowing us to eliminate option A. Likewise, since speed was assigned a new object, changes do not affect mySpeed in the main() method. Finally, the value of age in the Ski object does change to 18, as this was applied before the reference was changed. For these reasons, option C is correct."
    },
    {
      "number": 143,
      "answers": [
        "A"
      ],
      "explanation": "Member inner classes can now include static non-final members. Despite the unusual references in the main() method, the code is valid and does compile. The Penguin.this.volume value in the chick() method refers to the value defined at the Penguin instance level. Therefore, the code prints Honk(1)! at runtime, making option A correct."
    },
    {
      "number": 144,
      "answers": [
        "E"
      ],
      "explanation": "Records include useful overrides of the toString() method that include all attributes with both their name and value. For this reason, option E is correct. Note that if Fruit were a class instead of a record, then option A would be a possible output since it uses the version defined in Object."
    },
    {
      "number": 145,
      "answers": [
        "B"
      ],
      "explanation": "The code compiles, even if the blank is replaced with a constant char value, making option E incorrect. Note that the class correctly overrides both inherited default methods. It is possible to access a default method, even if it is overridden in the class, but requires using the super keyword properly. Option B demonstrates the correct syntax, while the other samples do not compile. Note that option D would not be correct even if there were only one inherited default method."
    },
    {
      "number": 146,
      "answers": [
        "C"
      ],
      "explanation": "Option A is incorrect because the keywords static and import are reversed. The Closet class uses the method getClothes() without a reference to the class name Store; therefore, a static import is required. For this reason, option B is incorrect since it is missing the static keyword. Option D is also incorrect since static imports are used with members of the class, not a class name. Finally, option C is the correct answer since it properly imports the method into the class using a static import."
    },
    {
      "number": 147,
      "answers": [
        "B"
      ],
      "explanation": "The drive() method in the Car class does not override the private version in the Automobile class since the method is not visible to the Car class. Therefore, the final attribute in the Automobile class does not prevent the Car class from implementing a method with the same signature. The drive() method in the ElectricCar class is a valid override of the method in the Car class, with the public access modifier expanding access in the subclass. In the main() method, the object created is an ElectricCar, even if it is assigned to a Car or Automobile reference. Due to polymorphism, the method from the ElectricCar will be invoked, making option B the correct answer."
    },
    {
      "number": 148,
      "answers": [
        "A",
        "D",
        "F"
      ],
      "explanation": "Option A is correct, as sealed classes may be extended by other sealed classes. In an unnamed module, the sealed class and its subclasses must be within the same package, making option B incorrect and option F correct. Option C is incorrect, as sealed classes can contain nested classes. Option D is also correct, as a sealed class can be declared abstract. Finally, option E is incorrect, as a sealed class cannot be declared final, or there would be no way to declare a subclass for it."
    },
    {
      "number": 149,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles, so option F is incorrect. The Music class is loaded, and the static initializers are executed in order, with re-fa- being printed first. Next, the first line of the main() method is executed, printing ti-. The second line of the main() method creates a Music object, with the instance initializers being called first, printing do-mi-. Finally, the no-argument constructor is executed, and so- is printed last, making option A correct."
    },
    {
      "number": 150,
      "answers": [
        "D"
      ],
      "explanation": "All of the options attempt to create an instance using an anonymous class that extends Sky. Option A is incorrect because when you create an anonymous class, you do not specify a name. Even if there was a Sunset class, the declaration of an anonymous class can only extend or implement one type directly. Since it would already extend Sunset, it cannot specify Sky at the same time. Option B is incorrect because Sky is abstract and cannot be instantiated directly. Option C is incorrect because it is missing a semicolon (;) at the end. Option D is the correct answer. Remember that all nested classes can have static variables."
    },
    {
      "number": 151,
      "answers": [
        "E"
      ],
      "explanation": "The code may look complicated, but it does not compile for a simple reason. The abstract read() method defined in Book cannot have a method body. Since it does, the code does not compile, and option E is correct."
    },
    {
      "number": 152,
      "answers": [
        "C"
      ],
      "explanation": "While using null with instanceof compiles, it always returns false. The other two instanceof calls show that instanceof can be used with both classes and interfaces. They both return true since Bus implements Vehicle, making option C correct."
    },
    {
      "number": 153,
      "answers": [
        "D"
      ],
      "explanation": "The first row is incorrect as the private modifier is required for private interface methods. The second row is correct. The third row is also incorrect because the static modifier is required, not optional, for static interface methods. The public modifier is optional, though, as the static method is implicitly public without it. The last row is incorrect as the abstract modifier can be implied if the method does not declare a body. Since three rows contain an error, option D is correct."
    },
    {
      "number": 154,
      "answers": [
        "D"
      ],
      "explanation": "A final instance variable must be assigned a value when it is declared, in an instance initializer or by a constructor. The Dwarf(String) constructor does not assign a value since it already contains a local variable called name. For this reason, this constructor does not compile, and option D is correct. If the assignment in the constructor were changed to this.name, then the program would compile and print Sleepy."
    },
    {
      "number": 155,
      "answers": [
        "C"
      ],
      "explanation": "The AddNumbers interface is a valid functional interface. While it includes both static and default methods, it includes only one abstract method, the precise requirement for it to be considered a functional interface, making option D incorrect. The class compiles and prints 8 at runtime, making option C correct."
    },
    {
      "number": 156,
      "answers": [
        "B"
      ],
      "explanation": "There is no such thing as package or pseudo variables, so options A and E are incorrect. Option C is incorrect as the variable is only in scope within a specific instance of the class. Option D is also incorrect as the variable is only in scope for a single method or block that it is defined in. Option B is the only correct answer as class variables are in scope within the program."
    },
    {
      "number": 157,
      "answers": [
        "D"
      ],
      "explanation": "The super() statement is used to call a constructor in a parent class, while the this() statement is used to call a constructor in the same class, making option D correct and option C incorrect. Options A, B, E, and F are incorrect because they are not built-in functionality in Java."
    },
    {
      "number": 158,
      "answers": [
        "C",
        "D"
      ],
      "explanation": "The default no-argument constructor is inserted by the compiler whenever a class, abstract or concrete, does not declare any constructors. For this reason, option A is incorrect and option D is correct. Even if a parent class does not declare a no-argument constructor, the child class can still declare one, making option B incorrect. If the parent class does not declare a no-argument constructor (and none is inserted by the compiler), then the child class must declare at least one constructor, making option C correct. Without a constructor call, inserting the default no-argument constructor into the child class would lead to a compiler error on the implicit super() call. Finally, options E and F are incorrect, as a child class of a parent with a no-argument constructor is free to declare or not declare any constructors."
    },
    {
      "number": 159,
      "answers": [
        "B"
      ],
      "explanation": "The hop() method has protected access, which allows subclasses to call it. Both the move() method and main() method are allowed to call hop() since Grasshopper is a subclass. The code runs without error and prints hop twice, making option B the answer."
    },
    {
      "number": 160,
      "answers": [
        "A"
      ],
      "explanation": "This code is not a functional interface because it has three abstract methods: fun(), game(), and toy(). Removing two of these three methods would cause the code to compile. However, there is no requirement that the code be a functional interface. Since it only needs to compile, removing the @FunctionalInterface annotation would also cause the code to compile. Option A is correct since it is the minimum number of lines that can be removed and have the code compile."
    },
    {
      "number": 161,
      "answers": [
        "A"
      ],
      "explanation": "An immutable class must not allow the state to change. The Flower class does this correctly. While the class isn't final, the getters are, so subclasses can't change the value returned. The Plant class lacks this protection, which makes it mutable. Option A is correct."
    },
    {
      "number": 162,
      "answers": [
        "C"
      ],
      "explanation": "The speak() method has private access, which does not allow code outside the class to call it. Therefore, option C is the answer."
    },
    {
      "number": 163,
      "answers": [
        "E"
      ],
      "explanation": "The sell() method does not compile because it does not return a value if both of the if statements' conditional expressions evaluate to false. While logically it is true that price is either less than 10 or greater than or equal to 10, the compiler does not know that. It just knows that if both if statements evaluate to false, then it does not have a return value; therefore, it does not compile. For this reason, option E is correct."
    },
    {
      "number": 164,
      "answers": [
        "E"
      ],
      "explanation": "Options A and C do not compile, as they are invalid ways of accessing a member variable. Options B and D both compile but print 100 at runtime, since they reference the speed variable defined in the Engine class. Option E is the correct answer, accessing the speed variable in the Racecar class and printing 88 at runtime."
    },
    {
      "number": 165,
      "answers": [
        "B",
        "C",
        "F"
      ],
      "explanation": "A static initializer can create instances of any class it has access to, so option A is incorrect. It can assign values to static final variables, specifically ones that have not been assigned a value already, so option B is correct. A static initializer is executed when the class is first loaded, not when an object is created or loaded, making option C correct, and options D and E incorrect. If the classes are never loaded, then they will not be executed, making option F correct."
    },
    {
      "number": 166,
      "answers": [
        "D"
      ],
      "explanation": "The class is loaded first, with the static initialization block called and 1 is printed. When the BlueCar is created in the main() method, the superclass initialization happens first. The instance initialization blocks are executed before the constructor, so 32 is outputted next. Finally, the object is created with the instance initialization blocks again being called before the constructor, outputting 45. The result is that 13245 is printed, making option D the correct answer."
    },
    {
      "number": 167,
      "answers": [
        "D"
      ],
      "explanation": "The code compiles, so options E and F are incorrect. Remember that the permits clause is optional if the sealed subclass is in the same file. Given the class declarations, all six nested subclasses inherit Fish. While Fish does include the non-sealed classes Nemo and Dory as descendants, they are marked private, which means they can't be extended outside the Fish class. Since it states the Fish class is unmodified, there are at most six subclasses of Fish, making option D correct."
    },
    {
      "number": 168,
      "answers": [
        "B"
      ],
      "explanation": "Recall that this refers to an instance of the current class. Therefore, any superclass of Canine can be used as a return type of the method. Since Canine inherits both Pet and Object, they can also be used as the return type. Note that these are all covariant with the inherited version from the Pet interface. Only List is incompatible, making option B correct."
    },
    {
      "number": 169,
      "answers": [
        "D"
      ],
      "explanation": "The static method getDrink() attempts to access an instance-based private method buyPopcorn() that results in a compiler error, making option D correct. The rest of the code compiles without issue."
    },
    {
      "number": 170,
      "answers": [
        "C"
      ],
      "explanation": "An instance method can access both instance variables and static variables. Both methods compile, and option C is correct."
    },
    {
      "number": 171,
      "answers": [
        "A"
      ],
      "explanation": "As ugly as the class looks, it does compile, making option A correct. Lines 2–4 each defines an instance method since they each have a name and return type. There is no rule saying you cannot define a method with the same name as the class, although it is considered bad style. The main() method calls the default no-argument constructor on line 6, inserted by the compiler. Finally, line 7 calls the method declared on line 2, which again calls the no-argument constructor inserted by the compiler."
    },
    {
      "number": 172,
      "answers": [
        "C"
      ],
      "explanation": "This method has package access, which means only classes in the same package can access it. In our case, these are the Red and Blue classes, making option C correct."
    },
    {
      "number": 173,
      "answers": [
        "D"
      ],
      "explanation": "This variable has protected access, which means code in the same package can access it in addition to subclasses. There are two classes in the com.color package and one class that subclasses it, making option D the answer."
    },
    {
      "number": 174,
      "answers": [
        "B",
        "D"
      ],
      "explanation": "Option A is incorrect because static methods cannot call instance methods directly. Options B and D are correct and are the primary reasons to create a static interface method. Options C and E are incorrect and describe attributes of a default method. Option F applies only to private static interface methods, not public ones."
    },
    {
      "number": 175,
      "answers": [
        "D"
      ],
      "explanation": "When overriding a method, a new or broader checked exception cannot be declared. The getNumStudents() method in HighSchool is an invalid override since it declares FileNotFoundException, which is not declared in the parent method. Since this is the only line that does not compile, option D is correct. Note that an abstract method can be overridden with a final method, as shown with getNumTeachers()."
    },
    {
      "number": 176,
      "answers": [
        "C"
      ],
      "explanation": "Having one class implement two interfaces that both define the same default method signature leads to a compiler error unless the class overrides the default method. In this case, the Sprint class overrides both walk() methods correctly; therefore, the code compiles without issue, and option C is correct. Note that the return types of the two default methods are different, but the overridden method uses a return type that is covariant with both."
    },
    {
      "number": 177,
      "answers": [
        "A"
      ],
      "explanation": "Interface methods without bodies are implicitly abstract and public. Therefore, both of these methods have the same signature. This means a class implementing them must implement a single wriggle() method, and option A is correct."
    },
    {
      "number": 178,
      "answers": [
        "C"
      ],
      "explanation": "A functional interface is required to have exactly one abstract method. In none of the interfaces does the default method count as an abstract method. Lion and Tiger are not functional interfaces since they contain two abstract methods. In both of these interfaces, roar() is abstract. The equals(Lion) method is similar to the equals(Object) in Object but is not an override of that method. Similarly, the toString() method in Tiger is also an abstract method. While there is a toString() method in Object, it does not take any parameters. On the other hand, Bear is a valid functional interface because it contains exactly one abstract method, making option C correct."
    },
    {
      "number": 179,
      "answers": [
        "B"
      ],
      "explanation": "The gold variable is marked final, which means it must be set either when it is declared or in a static initializer, as shown on line 17. It cannot be modified by a static method, though, so line 15 does not compile. Since this is the only line that does not compile, option B is correct. Line 8 compiles because the static method is modifying the local variable scaly, not the instance variable of the same name. Line 12 also compiles. While accessing a static variable via an instance is not recommended, it is allowed."
    },
    {
      "number": 180,
      "answers": [
        "B",
        "D",
        "E"
      ],
      "explanation": "An immutable class can have public constructors, so option A is incorrect. Options B, D, and E are correct and make up the requirements for an immutable class. Option D can be fulfilled by making the class final or marking the methods final. Option C is incorrect because instance variables can be declared with a value or set by an instance initializer. Option F is also incorrect. While it is common to mark instance variables final, as long as there is no way for them to be changed after the constructor is executed, the class can still be considered immutable."
    },
    {
      "number": 181,
      "answers": [
        "E"
      ],
      "explanation": "The code does not compile because the constant variable circumference does not declare a value, making option E correct. Remember that all variables within interfaces are implicitly static and final, so they must be initialized with a value when they are declared. The rest of the lines of code compile without issue. Note that while the static method leaveOrbit() cannot access the instance-based default method getCircumference() directly, it can through the reference variable earth."
    },
    {
      "number": 182,
      "answers": [
        "B"
      ],
      "explanation": "The code compiles, making options E and F incorrect. The record uses a compact constructor to set the same parameter twice, replacing the value passed into the constructor. The parameter isn't final, so this is allowed. At runtime, the code prints today's date, making option B correct."
    },
    {
      "number": 183,
      "answers": [
        "F"
      ],
      "explanation": "Trick question! Overloaded methods is correct in the first part of the sentence, but none of the answers is correct in the second part of the sentence. Remember, overridden methods can have covariant return types. They do not need to be the same. For this reason, option F is the correct answer."
    },
    {
      "number": 184,
      "answers": [
        "D"
      ],
      "explanation": "This class creates a final instance toy variable, but it is assigned a value twice. First, it is assigned a value in an instance initializer and then in a constructor. For this reason, the second line of the constructor does not compile, and option D is correct. The first line of the constructor, in which a static variable is referenced from an instance variable, is permitted but discouraged."
    },
    {
      "number": 185,
      "answers": [
        "C"
      ],
      "explanation": "Lines 15–17 create the three objects. Lines 18–19 change the references, so orange and banana point to each other. Lines 20–21 wipe out two of the original references. This means the object with name as x is inaccessible. Option C matches this scenario."
    },
    {
      "number": 186,
      "answers": [
        "C"
      ],
      "explanation": "Option A is incorrect because Java inserts a no-argument constructor only if there are no other constructors in the class. Option B is incorrect because the parent can have a default no-argument constructor, which is inserted by the compiler and accessible in the child class. Option D is incorrect. A class that contains two no-argument constructors will not compile because they would have the same signature. Finally, option C is correct. If a class extends a parent class that does not include a no-argument constructor, the default no-argument constructor cannot be automatically inserted into the child class by the compiler. Instead, the developer must explicitly declare at least one constructor and explicitly define how the call to the parent constructor is made."
    },
    {
      "number": 187,
      "answers": [
        "C"
      ],
      "explanation": "Building and House are both properly declared inner classes. Any House object can be stored in a Building reference, making the declarations for b2, b3, and b4 compile. The declaration for h3 is also correct. It so happens that b2 is a House object, so the cast works. The declaration of h2 is a problem, though. While the cast itself is fine, a Building cannot be stored in a House reference, which means the assignment fails to compile. Option C is correct and is the only line with a compiler error in this code. Note that if the declaration of h2 were removed, the declaration of b3 would produce a ClassCastException at runtime."
    },
    {
      "number": 188,
      "answers": [
        "E"
      ],
      "explanation": "This main() method declares an anonymous class that implements the Tasty interface. Interface methods are public, whereas the override in the anonymous class uses package access. Since this reduces the visibility of the method, the declaration of eat() on line 9 does not compile. Next, the declaration of the apple object must end with a semicolon (;) on line 12, and it does not. For these two reasons, the code does not compile, and option E is the correct answer. Note that if these two issues were corrected, then the correct answer would be option C because the code does not actually call the eat() method; it just declares it."
    },
    {
      "number": 189,
      "answers": [
        "B"
      ],
      "explanation": "Java supports only a single return data type or void. Therefore, it is not possible to define a functional interface that returns two data types, making option A incorrect. While many of the built-in functional interfaces use generics, functional interfaces that use primitives certainly exist, making option B the correct answer. Option C is incorrect because a functional interface that takes no values and returns void is possible. In fact, Runnable is one such example. Option D is also incorrect, since IntFunction<R> takes a primitive argument as input and a generic argument for the return type."
    },
    {
      "number": 190,
      "answers": [
        "C"
      ],
      "explanation": "The init() method is accessible only from the same package. Since Tortoise is in a different package, the method is not available, and option C is correct. Line x2 does not compile either since Tortoise is in a different package and not a subclass. However, the question asks about the first line."
    },
    {
      "number": 191,
      "answers": [
        "A"
      ],
      "explanation": "The code does not contain any compilation errors, making option A correct. While an abstract class cannot be marked final, a concrete class extending it can be. Likewise, a concrete method overriding an abstract one can also be marked final. In the ParkVisit class, the getValue() method accesses the effectively final variables width and fun. Finally, a class can override a method that it inherits from both an interface and an abstract class, provided the method signatures are compatible."
    },
    {
      "number": 192,
      "answers": [
        "E"
      ],
      "explanation": "The Evergreen class does not compile because there is no default access modifier keyword that can be applied to methods in a class. The Bush class does not compile because leaves has package access and Bush is in a different package. Since both classes do not compile, option E is the correct answer."
    },
    {
      "number": 193,
      "answers": [
        "F"
      ],
      "explanation": "While sealed classes are similar to enums, they cannot be used in switch statements like enums in Java 17. For this reason, the main() method does not compile, making option F correct. The two subclass declarations compile without issue."
    },
    {
      "number": 194,
      "answers": [
        "B"
      ],
      "explanation": "Marking an interface method private improves the encapsulation of the class, making option B correct. Options A and D are incorrect as static methods cannot be overridden, regardless if they are marked private. Option C is incorrect, as adding private to a method reduces the visibility of the method. Options E and F are flat-out wrong."
    },
    {
      "number": 195,
      "answers": [
        "E"
      ],
      "explanation": "Since a constructor call is not the first line of the RainForest() constructor, the compiler inserts the no-argument super() call. Since the parent class, Forest, does not define a no-argument constructor, the RainForest() constructor does not compile, and option E is correct."
    },
    {
      "number": 196,
      "answers": [
        "B"
      ],
      "explanation": "First, the color variable defined in the instance and set to red is ignored in the method printColor(). Since local scope overrides instance scope, option A is incorrect. The value of color passed to the printColor() method is blue, but that is lost by the assignment of purple, making option B the correct answer and option C incorrect. Options D and E are incorrect as the code compiles and prints a value."
    },
    {
      "number": 197,
      "answers": [
        "E"
      ],
      "explanation": "The play() method is overridden in Saxophone for both Horn and Woodwind, so the return type must be covariant with both. Object and Number do not work, because neither is a subclass of Integer or Short. As stated in the question text, both Integer and Short extend Number directly, so neither can be a subclass of the other. Therefore, nothing can fill in the blank that would allow this code to compile, and option E is correct."
    },
    {
      "number": 198,
      "answers": [
        "A",
        "B",
        "C"
      ],
      "explanation": "Options A, B, and C are correct statements about abstract classes. Option D is incorrect as Java allows a class to extend only one class directly, abstract or otherwise. Option E is incorrect, as a class can implement or inherit an interface. Option F is also incorrect as classes can only extend classes, and interfaces can only extend interfaces."
    },
    {
      "number": 199,
      "answers": [
        "C"
      ],
      "explanation": "The code does not compile. First, the enum list is not terminated with a semicolon (;), which is required when an enum includes anything beyond just the list of values. Second, the access modifier of TRUE's implementation of getNickName() is package, but the abstract method signature has a protected modifier. Since package access is a more restrictive access than protected, the override is invalid, and the code does not compile. For these two reasons, option C is the correct answer. Note that the value variable is not final or properly encapsulated and can therefore be modified by callers outside the enum. This is permitted but considered a poor practice."
    },
    {
      "number": 200,
      "answers": [
        "E"
      ],
      "explanation": "The hop() method has protected access, which allows subclasses to call it, making line p1 correct. The HopCounter class is allowed to call the move() method because it is public. However, it is not allowed to call the hop() method since it is referencing a subclass, but not in one. Therefore, option E is the answer."
    },
    {
      "number": 201,
      "answers": [
        "B",
        "C"
      ],
      "explanation": "Only interfaces can contain default methods, making option B correct. Interfaces cannot contain protected methods, making option C the other correct answer."
    },
    {
      "number": 202,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "Options A and D would not allow the class to compile because two methods in the class cannot have the same name and arguments, but a different return value. Option C would allow the class to compile, but it is not a valid overloaded form of our findAverage() method since it uses a different method name. Options B and E are correct overloaded versions of the findAverage() method, since the name is the same but the arguments are different. While new checked exceptions are not permitted for overridden methods, they are allowed for overloaded methods. Option F is incorrect because the method is overridden, not overloaded, and the visibility of the inherited method cannot be reduced."
    },
    {
      "number": 203,
      "answers": [
        "A",
        "E"
      ],
      "explanation": "Options A and E are correct since method names may include the underscore (_) character as well as currency ($) symbols. Note that there is no rule that requires a method to start with a lowercase character; it is just a practice adopted by the community. Options B and F are incorrect because the hyphen (-) and pound (#) characters may not be part of a method name. Option C is incorrect since new is a reserved word in Java. Finally, option D is incorrect. A method name must start with a letter, a currency ($) symbol, or an underscore (_) character."
    },
    {
      "number": 204,
      "answers": [
        "C"
      ],
      "explanation": "A functional interface must include exactly one abstract method, either by inheritance or declared directly. It may also have any number, including zero, of default or static methods. For this reason, both parts of option D are incorrect. The first part of option A is incorrect because more than one abstract method disqualifies it as a functional interface. The first part of option B is incorrect because the method must be abstract. Finally, option C is the correct answer. The first part of the sentence defines what it means to be a functional interface. The second part refers to the optional @FunctionalInterface annotation. It is considered a good practice to add this annotation to any functional interfaces you define because the compiler will report a problem if you define an invalid interface that does not have exactly one abstract method."
    },
    {
      "number": 205,
      "answers": [
        "F"
      ],
      "explanation": "The code compiles, even if the blank is replaced with a constant int value, making option E incorrect. The private method play() declared in the Sport interface is not accessible in the Game class. For this reason, option F is correct."
    },
    {
      "number": 206,
      "answers": [
        "E"
      ],
      "explanation": "The code does not compile because two of the constructors contain a cyclic reference to each other. The MoreMusic(int) constructor calls this(null), which only matches the MoreMusic(String) constructor. Then, the MoreMusic(String) constructor calls this(9), which only matches the MoreMusic(int) constructor. The compiler notices this circular dependency and does not allow the code to compile, making option E correct."
    },
    {
      "number": 207,
      "answers": [
        "A"
      ],
      "explanation": "Both classes compile without issue, and the Hug program prints kitty - 5.0, making option A the answer. In the Kitten class, all of the variables have package access as the access modifiers are commented out. Also, there is no age variable since the entire line is commented out."
    },
    {
      "number": 208,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles without issue. The main() method creates an instance of an anonymous class of Ready. Calling r.first retrieves the static variable within Ready, printing 2 on line n3. On line n4, there is no reference so the static variable of GetSet is called, printing 10. For these reasons, option A is correct."
    },
    {
      "number": 209,
      "answers": [
        "D"
      ],
      "explanation": "The init() method is accessible from any class. The race() method is available to a subclass in a different package, but only if it is inherited. In particular, this.race() would compile on line x2. Since the method is being executed on an arbitrary instance of Hare, though, it is not accessible. For this reason, line x2 does not compile and option D is correct."
    },
    {
      "number": 210,
      "answers": [
        "E"
      ],
      "explanation": "A record cannot include an abstract method, so the transform() declaration does not compile. A record is implicitly final and it cannot be used in an anonymous class declaration, so the main() method does not compile. You also cannot pass a value, null, to an anonymous class declaration. For these reasons, option E is correct."
    },
    {
      "number": 211,
      "answers": [
        "E"
      ],
      "explanation": "The Story class does not compile since a static method cannot call an instance method. The Movie class does not compile because it tries to instantiate a Story object, which is abstract. Since neither class compiles, option E is correct."
    },
    {
      "number": 212,
      "answers": [
        "C"
      ],
      "explanation": "The Rotorcraft class includes an abstract method, but the class itself is not marked abstract. Only interfaces and abstract classes can include abstract methods. Since the code does not compile, option C is the correct answer. If the abstract method were removed, then the code would compile and produce a ClassCastException on the first line of the main() method at runtime."
    },
    {
      "number": 213,
      "answers": [
        "D"
      ],
      "explanation": "The Super class is marked final, which means it cannot be used as the supertype of an anonymous class. For this reason, line 6 does not compile, and option D is correct. The rest of the lines compile without issue."
    },
    {
      "number": 214,
      "answers": [
        "B"
      ],
      "explanation": "The code compiles without issue. The reference r.go.first refers to the value in the GetSet instance, which is 5. The r.go.second actually refers to a static variable accessed via an instance reference. In this case, DEFAULT_VALUE is accessible within GetSet and resolves to 10. For this reason, option B is correct."
    },
    {
      "number": 215,
      "answers": [
        "A",
        "D"
      ],
      "explanation": "The static class variables cannot be used with var since they are not local variables. Therefore, options E and F are incorrect. Options A and D are correct because string concatenation is used here instead of addition, due to \"\" + at the start of the expression."
    },
    {
      "number": 216,
      "answers": [
        "F"
      ],
      "explanation": "The code does not compile, as the constructor calls on the first four lines of the main() method are missing the new keyword. For this reason, option F is correct. If the missing new keywords were added to each line, then the code would compile, and three Gems objects would be available for garbage collection."
    },
    {
      "number": 217,
      "answers": [
        "B"
      ],
      "explanation": "The code does not compile, so option A is incorrect. The first method, Stars(), looks like a no-argument constructor, but since it has a return value of void, it is a method, not a constructor. Since only constructors can call super(), the code does not compile due to this line. The only constructor in this class, which takes an int value as input, performs a pointless assignment, assigning a variable to itself. While this assignment has no effect, it does not prevent the code from compiling. Finally, the main() method compiles without issue since we just inserted the full package name into the class constructor call. This is how a class that does not use an import statement could call the constructor. Since the method is in the same class, and therefore the same package, it is redundant to include the package name but not disallowed. Because only one line causes the class to fail to compile, option B is correct."
    },
    {
      "number": 218,
      "answers": [
        "A"
      ],
      "explanation": "Although the casting is a bit much, the object in question is a SoccerBall. Since SoccerBall extends Ball and implements Equipment, it can be explicitly cast to any of those types, so no compilation error occurs. At runtime, the object is passed around and, due to polymorphism, can be read using any of those references since the underlying object is a SoccerBall. In other words, casting it to a different reference variable does not modify the object or cause it to lose its underlying SoccerBall information. Therefore, the code compiles without issue, and option A is correct."
    },
    {
      "number": 219,
      "answers": [
        "F"
      ],
      "explanation": "The question may appear to be about method overriding, but it is in fact about member inner classes. In fact, all of the method overrides are valid in this class. The code does not compile because the charge() method is static (even though it is called on an instance), which means it requires an instance to instantiate a member of the member inner class MyTrunk. For this reason, the call to new MyTrunk() does not compile, and option F is correct."
    },
    {
      "number": 220,
      "answers": [
        "D"
      ],
      "explanation": "Lines 3 and 4 do not compile because the returned values of double and long are not compatible with int. Lines 6 through 8 compile without issue, since each method takes a different set of input arguments. The first line of the main() method does not compile either, making option D correct. The no-argument version of the nested() method does not return a value, and trying to output a void return type in the print() method doesn't compile."
    },
    {
      "number": 221,
      "answers": [
        "D"
      ],
      "explanation": "Line 18 compiles because neither type is specified for the lambda parameters. Lines 19 and 22 compile because the lambda parameters use a type or var consistently. These are the three lines that compile, making option D correct. Lines 20 and 21 do not compile because var must be used for all parameters in a lambda if it is used for any."
    },
    {
      "number": 222,
      "answers": [
        "C"
      ],
      "explanation": "This example deals with method signatures rather than polymorphism. Since the hop() methods are static, the precise method called depends on the reference type rather than the actual type of the object. Since the first reference is Rabbit, the first value printed is hop. The second reference actually is FlemishRabbit, so HOP is printed, and option C is the answer."
    },
    {
      "number": 223,
      "answers": [
        "A"
      ],
      "explanation": "The code starts by creating a list of three elements. On line 16, it removes two elements and then removes the final one on line 19. Line 17 prints [9], although this is not an answer choice. Line 20 prints an empty list, making option A the correct answer. Note that num is effectively final so can be used in a lambda."
    },
    {
      "number": 224,
      "answers": [
        "B"
      ],
      "explanation": "The code successfully defines a local variable inside the lambda. The lambda returns baby each time it is executed. Since we have a List, all three are output, and option B is the correct answer."
    },
    {
      "number": 225,
      "answers": [
        "B"
      ],
      "explanation": "This class does not implement Serializable, so option A is incorrect. This code is well encapsulated because the instance variables are private. While the instance variable references do not change after the object is created, the contents of fauna can be modified, so it is not immutable. For these reasons, option B is correct."
    },
    {
      "number": 226,
      "answers": [
        "E"
      ],
      "explanation": "While the compact constructor declaration is valid, the overloaded constructor declaration is not. An overloaded record constructor must begin with an explicit call to another constructor via this(). Even if a call were added, such as this(\"B\", 10f), the constructor would not compile since record fields are final and cannot be set twice. For this reason, option E is correct."
    },
    {
      "number": 227,
      "answers": [
        "B"
      ],
      "explanation": "The Dress type is declared as a class, not an interface. For this reason, it cannot contain the default method getSize(), making option B correct. The rest of the methods compile within the class declaration without issue."
    },
    {
      "number": 228,
      "answers": [
        "C",
        "E"
      ],
      "explanation": "Options A and B are incorrect and describe properties of default interface methods. Option C is correct and one of the primary reasons to add a private interface method. Option D is not a property of private interface methods. Option E is also correct, as private interface methods are not exposed to classes implementing the interface. Option F is a nonsensical statement."
    },
    {
      "number": 229,
      "answers": [
        "C"
      ],
      "explanation": "The permits clause is optional if the subclasses are contained within the same file. When provided, though, all of the subclasses must be specified. Since Toast and IceCream are not listed, they do not compile. Since only Lollipop and Treat compile, option C is correct. Note that if the permits clause were removed, then all of the classes would compile."
    },
    {
      "number": 230,
      "answers": [
        "A"
      ],
      "explanation": "A static import is used to import static members of another class. Option A is the correct way to import the static members of a class. Options C and D reverse the keywords static and import, while option B incorrectly imports a class, which cannot be imported via a static import."
    }
  ]
}