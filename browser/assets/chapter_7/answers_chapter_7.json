{
  "answers": [
    {
      "number": 1,
      "answers": ["F"],
      "explanation": "The module-info.java file is indeed used to declare a module, making option F the correct answer."
    },
    {
      "number": 2,
      "answers": ["E"],
      "explanation": "The service locator contains a load() method, not an exports() method, making option E the correct answer."
    },
    {
      "number": 3,
      "answers": ["B", "D"],
      "explanation": "A service in Java consists of the interface, any classes the interface references, and a way to look up implementations of the interface. Option B covers the lookup mechanism (service locator), and option D covers the interface itself."
    },
    {
      "number": 4,
      "answers": ["B"],
      "explanation": "A named module must be on the module path and contain a module-info file. Only dog.bark meets this criterion, making option B the answer."
    },
    {
      "number": 5,
      "answers": ["C"],
      "explanation": "An automatic module must be on the module path but does not contain a module-info file. Option C is correct because dog.hair matches this description."
    },
    {
      "number": 6,
      "answers": ["E"],
      "explanation": "There is no such thing as a default module. The types of modules in Java are automatic, named, and unnamed. Option E correctly identifies this."
    },
    {
      "number": 7,
      "answers": ["C"],
      "explanation": "An unnamed module must be on the classpath. It is rare to have a module-info file in an unnamed module, but it is allowed. Therefore, dog.fluffy and dog.husky both meet this criterion, making option C correct."
    },
    {
      "number": 8,
      "answers": ["B", "F"],
      "explanation": "It is recommended to specify all exports directives in the module-info file. Using --add-exports is legal but not recommended (option B). There is no equivalent option for requires, so option F is correct."
    },
    {
      "number": 9,
      "answers": ["B"],
      "explanation": "Java does not allow dashes in identifier names, and access modifiers like public are not permitted in module declarations. The only valid declaration among the options is the first one, making option B correct."
    },
    {
      "number": 10,
      "answers": ["D"],
      "explanation": "The consumer and service provider interface are generally separate. The service locator and service provider interface are decoupled from the service provider. Option D correctly identifies this."
    },
    {
      "number": 11,
      "answers": ["C"],
      "explanation": "The java command has an option --list-modules to list all the modules that come with the JDK. Option C is correct."
    },
    {
      "number": 12,
      "answers": ["D"],
      "explanation": "The rules for module names include removing the extension and changing special characters to periods (.). Option D (dog.arthur2) is the correct module name according to these rules."
    },
    {
      "number": 13,
      "answers": ["C"],
      "explanation": "All parts of a module's service must point to the service provider interface. Given the dependencies described, the service provider must be Y, making option C correct."
    },
    {
      "number": 14,
      "answers": ["B"],
      "explanation": "The consumer depends on the service provider interface and service locator but not directly on the service provider. Option B correctly identifies the service locator based on the dependencies described."
    },
    {
      "number": 15,
      "answers": ["C"],
      "explanation": "A cyclic dependency occurs when two modules depend on each other directly or indirectly. Option C correctly identifies the situation where chicken.jar and egg.jar have a cyclic dependency."
    },
    {
      "number": 16,
      "answers": ["E"],
      "explanation": "The ServiceLoader.load() method returns an Iterable, not a Stream. Adding stream() would make option D correct."
    },
    {
      "number": 17,
      "answers": ["C"],
      "explanation": "Each module must have its own module-info.java file in its root directory. For module com.ny, this location is W, and for module com.sf, this location is Y. Option C correctly identifies this."
    },
    {
      "number": 18,
      "answers": ["E"],
      "explanation": "Options A, C, and D are incorrect because 'export' and 'require' are not directives in modules. Option B is incorrect because 'exports' should go in the com.ny module, not com.sf. Option E correctly uses 'requires' to reference a module name rather than a package."
    },
    {
      "number": 19,
      "answers": ["D"],
      "explanation": "Options A and B are incorrect because 'export' is not a directive in modules. Option E should belong in the com.sf module, not com.ny. Option F is incorrect because 'requires' should reference a module name rather than a package. Option D correctly uses 'exports' to reference a package name."
    },
    {
      "number": 20,
      "answers": ["E"],
      "explanation": "The Maple class is intended to implement the Tree interface, which must be accessible. This module is missing a 'requires nature.sapling;' statement, making option E the correct answer."
    },
    {
      "number": 21,
      "answers": ["B"],
      "explanation": "The -c option is not valid for the javac command. Option B correctly identifies that the -d option specifies the directory and the -p option specifies the module path."
    },
    {
      "number": 22,
      "answers": ["A", "C", "E"],
      "explanation": "Option A is correct because java.base is automatically available. Options C and E are also correct because java.desktop and java.sql are modules supplied with the JDK."
    },
    {
      "number": 23,
      "answers": ["A", "C"],
      "explanation": "Option A is correct because a top-down migration starts by moving all modules to the module path as automatic modules. Option C is also correct because each module is then changed from an automatic module to a named module."
    },
    {
      "number": 24,
      "answers": ["A"],
      "explanation": "Option A is correct because a consumer typically requires both the service provider interface and the service locator."
    },
    {
      "number": 25,
      "answers": ["A", "C"],
      "explanation": "Option A is correct because it's preferable to create named modules where possible. Option C is also correct because avoiding cyclic dependencies is important in modular design."
    },
    {
      "number": 26,
      "answers": ["B"],
      "explanation": "The jdeps command with the -s option provides a summary of output, not verbose output. Option B correctly identifies this."
    },
    {
      "number": 27,
      "answers": ["C"],
      "explanation": "Option C is correct because a service provider module typically requires the service provider interface module and provides the implementation of the service."
    },
    {
      "number": 28,
      "answers": ["E"],
      "explanation": "When running a module, the module name precedes the slash, followed by the fully qualified class name. Option E is the only one that correctly formats this."
    },
    {
      "number": 29,
      "answers": ["B"],
      "explanation": "An unnamed module is on the classpath and ignores any module-info file present. An automatic module is on the module path and does not have a module-info file. A named module requires a module-info file. Option B correctly identifies these characteristics."
    },
    {
      "number": 30,
      "answers": ["B"],
      "explanation": "Option B is correct because a service locator typically uses the service provider interface and requires the service provider interface module while exporting the package with the locator."
    },
    {
      "number": 31,
      "answers": ["D"],
      "explanation": " Option D is correct because the jlink command creates a Java runtime using the modules you require and have specified."
    },
    {
      "number": 32,
      "answers": ["E"],
      "explanation": " A consumer requires both the service locator and service provider interface. A service locator and service provider interface need to have an exports statement. A service provider needs a provides directive. Since none of them match, option E is the answer."
    },
    {
      "number": 33,
      "answers": ["F"],
      "explanation": " An unnamed module is permitted to have a module-info file, but the file is ignored if present. An automatic module does not have a module-info file. A named module is required to have a module-info file. Therefore, option F is correct."
    },
    {
      "number": 34,
      "answers": ["A"],
      "explanation": " A module-info file is required to start with module rather than class. Therefore, the first line doesn't compile, and option A is correct."
    },
    {
      "number": 35,
      "answers": ["B"],
      "explanation": " You need to know these directives: exports, requires, requires transitive, provides, opens, and uses. Of these, only uses is in the list of candidates in the question, which means option B is correct. Note that export and require are invalid because they should be exports and requires, respectively."
    },
    {
      "number": 36,
      "answers": ["D"],
      "explanation": " Option D is correct because a service provider interface exposes the interface without depending on any of the other options."
    },
    {
      "number": 37,
      "answers": ["D", "E", "F"],
      "explanation": " The java.base module is automatically available to any module without specifying it. However, this question tries to trick you with option A by specifying jdk.base instead. Similarly, java.desktop exists, but not jdk.deskop, making option C wrong. Options D, E, and F are correct because jdk.javadoc, jdk.jdeps, and jdk.net are modules supplied with the JDK. You do need to be able to recognize the names of built-in modules."
    },
    {
      "number": 38,
      "answers": ["B", "C", "F"],
      "explanation": " A top-down migration starts by moving all the modules to the module path as automatic modules, making options B and F correct. A bottom-up migration moves each module after all the modules it depends on have been migrated, making option C correct."
    },
    {
      "number": 39,
      "answers": ["B"],
      "explanation": " The service locator contains a load() method, making option B correct."
    },
    {
      "number": 40,
      "answers": ["E"],
      "explanation": " Module names are permitted to be any valid variable name with the addition of dot separators (.). The only one that is problematic is com-leaf because dashes are not allowed, making option E correct. As a reminder, numbers are permitted as long as they are not the first character in a segment. Capital letters are discouraged but allowed."
    },
    {
      "number": 41,
      "answers": ["A"],
      "explanation": " Option A is correct because ServiceLoader allows you to make your application extensible. A service can be added without recompiling the entire application. It is a class, but the service provider implementation does not reference it, making options C and D incorrect. Option B is not a feature of modules."
    },
    {
      "number": 42,
      "answers": ["A", "F"],
      "explanation": " Code on the classpath has not yet been migrated to modules and can reference any code in the application. This is true whether that code is in automatic, named, or unnamed modules, matching option A. Code on the module path operates in a stricter world and cannot reference code on the classpath. Since unnamed modules cannot be accessed in this situation, option F is the second answer."
    },
    {
      "number": 43,
      "answers": ["C"],
      "explanation": " Option A is incorrect because it exports the package to all modules. Option C is correct because it limits package sharing to the com.park module. Option E is incorrect because a package must be exported from the module that contains it. Options B and D are incorrect because from is not valid syntax."
    },
    {
      "number": 44,
      "answers": ["F"],
      "explanation": " It is not possible to provide access outside the module while also limiting access within the com.duck module. Options A and C are tempting because they do provide access in com.park. However, they do not prevent the Egg class in the com.egg package from accessing the com.duckling package. Remember that the com.egg package is in the com.duck module, so the access cannot be restricted. Therefore, option F is correct."
    },
    {
      "number": 45,
      "answers": ["E"],
      "explanation": " The correct way to specify this is requires com.duck; requires com.bread;. There is no way to combine two module requires statements into one. Additionally, note that the requires statement works with a module name, not a package name. Since none of these are correct, option E is the answer."
    },
    {
      "number": 46,
      "answers": ["E"],
      "explanation": " Only the service provider has a provides directive. Since it is not part of the service, option E is the correct answer."
    },
    {
      "number": 47,
      "answers": ["C"],
      "explanation": " Both options A and B note that the JAR depends on the jdk.unsupported module. However, they do not list suggested replacements. Option C is correct and option F is incorrect because the desired flag is -jdkinternals."
    },
    {
      "number": 48,
      "answers": ["C"],
      "explanation": " Option C is correct because only unnamed modules are on the classpath."
    },
    {
      "number": 49,
      "answers": ["D"],
      "explanation": " The service locator contains a ServiceLoader call to look up the service implementations. It takes the type of class to look up as a parameter and returns a generic, making option D the correct answer."
    },
    {
      "number": 50,
      "answers": ["B", "D"],
      "explanation": " Option B is correct because it depends on the change. If a method is added to the service provider interface or a public method is changed, the service providers must be recompiled. However, if a change is made that does not affect the service provider, such as a new static method, recompilation is not needed. Option D is also correct because return types and parameter types are considered part of the service."
    },
    {
      "number": 51,
      "answers": ["D"],
      "explanation": " Unnamed modules are on the classpath. Option D is correct because automatic and named modules are on the module path."
    },
    {
      "number": 52,
      "answers": ["F"],
      "explanation": " The consumer needs to depend on the shared module, making it X. The shared module then has to be Z, and the service provider has to be Y. However, the service provider should not know about the consumer and the dotted line in the diagram does not make sense. This means none of the options can create a valid scenario, and option F is the answer."
    },
    {
      "number": 53,
      "answers": ["B"],
      "explanation": " Without any command-line flags, jdeps lists packages and module dependencies. The -s flag provides a summary and omits the package name, which means option B is the correct answer."
    },
    {
      "number": 54,
      "answers": ["E"],
      "explanation": " The --output flag provides the desired output directory. There is no abbreviated form for this option, making option E the answer."
    },
    {
      "number": 55,
      "answers": ["F"],
      "explanation": " The first clue is that the -m and -p options are on the java command. Beyond that, you need to memorize the name of the --show-module-resolution option. This makes option F correct."
    },
    {
      "number": 56,
      "answers": ["B"],
      "explanation": " This module is a service provider interface. The only requirement is that the module needs to export the package containing the interface. In this case, that is the animal.insect.api.bugs package, which matches option B."
    },
    {
      "number": 57,
      "answers": ["A", "E"],
      "explanation": " This module is a service provider. It needs a requires directive for the service provider interface, which is option A. It also needs a provides directive, which specifies both the interface and implementation. Option E has both in the correct order."
    },
    {
      "number": 58,
      "answers": ["C", "F"],
      "explanation": " This module is a service locator. It needs three directives: exports, requires, and uses. The requires directive specifies the module it depends on, which is option C. The uses directive specifies the service provider interface it references, which is option F."
    },
    {
      "number": 59,
      "answers": ["A", "B"],
      "explanation": " This module is a consumer. It needs two requires directives. Option A is correct because it represents the service provider interface. Additionally, option B is correct as it represents the service locator. The uses directive should be in the service locator, not the consumer."
    },
    {
      "number": 60,
      "answers": ["A"],
      "explanation": " Without any command-line flags, jdeps lists packages and module dependencies, making option A correct. Option D will also list the packages; however, it is longer than option A."
    },
    {
      "number": 61,
      "answers": ["C"],
      "explanation": " The com.light module does not have any dependencies, so it is fine. However, com.animal and com.plant depend on each other, giving us a cyclic dependency. Finally, com.worm depends on all the modules but does not introduce any more problems. It will not compile until com.animal or com.plant are fixed but is not part of the cycle itself. Option C is correct, since only two modules are part of the cycle."
    },
    {
      "number": 62,
      "answers": ["C"],
      "explanation": " The -d option is shorthand for --describe-module on both the jar and java commands. Therefore, option C is correct."
    },
    {
      "number": 63,
      "answers": ["C"],
      "explanation": " The javac command takes -p for the module path rather than -m. Therefore, option C is the correct answer."
    },
    {
      "number": 64,
      "answers": ["A"],
      "explanation": " Option B is tempting because the java.lang package is available to all classes. However, the question asks about modules. Option A is the answer because the java.base module is available to all modules. The other options are incorrect because those modules do not exist."
    },
    {
      "number": 65,
      "answers": ["A", "B", "C"],
      "explanation": " The jmod command has five possible modes: create, extract, describe, list, and hash. This makes options A, B, and C the answer."
    },
    {
      "number": 66,
      "answers": ["A"],
      "explanation": " There is no such thing as a side-to-side migration, ruling out option B. In a top-down migration, all modules are moved to the module path first, making option C incorrect. In a bottom-up migration, modules are moved, starting with those without dependencies. Therefore, option A is correct."
    },
    {
      "number": 67,
      "answers": ["C", "E"],
      "explanation": " In a bottom-up migration, the lowest-level modules are migrated to named modules on the module path first. This makes option E one of the answers. The modules that remain on the classpath are unnamed modules, making option C the other answer."
    },
    {
      "number": 68,
      "answers": ["D"],
      "explanation": " The com.magic module exports only one package. This makes the com.magic.unicorn package accessible, but not the com.magic.dragon package. Both packages in com.science are accessible because it is an automatic module. When a module on the module path does not contain a module-info file, all packages are exported. This gives us three packages that are accessible and an answer of option D."
    },
    {
      "number": 69,
      "answers": ["A"],
      "explanation": " Modules on the module path cannot access anything from the classpath, making option A the answer."
    },
    {
      "number": 70,
      "answers": ["E"],
      "explanation": " Option E is correct as this code does compile. Although it is uncommon, a module is not required to have any directives in the body. Similarly, module names are lowercase and have more than one component by convention. None of these problems prevent the file from compiling, though."
    },
    {
      "number": 71,
      "answers": ["E"],
      "explanation": " One of the benefits of services is not having to recompile existing code when adding a new implementation. This makes option E the answer."
    },
    {
      "number": 72,
      "answers": ["C"],
      "explanation": " The java command uses -m and --module to supply the module name. The jdeps command uses -s and --summary to specify that the output should be limited. Option C matches both of these."
    },
    {
      "number": 73,
      "answers": ["B"],
      "explanation": " A service consists of the interface, any classes the interface references, and a way to look up implementations of the interface. It does not include the implementation. This makes option B the answer."
    },
    {
      "number": 74,
      "answers": ["A"],
      "explanation": " Option A is correct because only jdeps uses this -s."
    },
    {
      "number": 75,
      "answers": ["A", "E"],
      "explanation": " This question is tricky because the service provider code is shown, but the question asks about the service locator, and you need to infer information about the service provider interface. Option B is incorrect because the requires directive references a module name rather than an interface. Option C is incorrect because we need the service provider interface module, and it refers to the service provider module. The requires directive is option A due to process of elimination. Option E is easier, since the uses directive works with an interface name. Therefore, options A and E are the answers."
    },
    {
      "number": 76,
      "answers": ["A", "F"],
      "explanation": " A bottom-up migration leaves unnamed modules on the classpath until they are migrated to the module path, making option A correct and option D incorrect. A top-down migration immediately moves all modules to the module path as automatic modules, making options B and E incorrect. Therefore, option F is the other answer."
    },
    {
      "number": 77,
      "answers": ["D"],
      "explanation": " The ServiceLoader class has a load() method that returns a Collection of Provider. Option D is correct because we need to convert the Provider into a Mouse."
    },
    {
      "number": 78,
      "answers": ["B", "C", "E"],
      "explanation": " The mammal module depends on two other modules. Since requires references module names, options C and E are correct. The module also has one package, which is referenced in the exports directive. This makes option B correct as well."
    },
    {
      "number": 79,
      "answers": ["C"],
      "explanation": " The transitive keyword goes after requires, ruling out all but options C and D. Just like requires, requires transitive references a module name, narrowing it down to option C."
    },
    {
      "number": 80,
      "answers": ["D"],
      "explanation": " Any requires directives must reference unique modules. Using the transitive keyword does not change this requirement, making option D the answer."
    },
    {
      "number": 81,
      "answers": ["D"],
      "explanation": " There can be multiple service providers for a single service provider interface, making option D the answer."
    },
    {
      "number": 82,
      "answers": ["A", "D", "E"],
      "explanation": " The java.logging, java.management, and java.naming modules exist, making options A, D, and E correct. Option B is tempting. However, jdk.javadoc exists, not java.javadoc. Options C and F are completely made up."
    },
    {
      "number": 83,
      "answers": ["B", "E"],
      "explanation": " Option E is correct because all modules on the classpath are unnamed modules. On the module path, we can have automatic or named modules. In this case, it is an automatic module because there is no module-info.class at the root of the JAR. Having that file in another directory is ignored. This makes option B the other answer."
    },
    {
      "number": 84,
      "answers": ["A"],
      "explanation": " The consumer needs to depend on the shared module, making it X. The shared module then has to be Z, and the service provider has to be Y. This makes option A correct."
    },
    {
      "number": 85,
      "answers": ["B", "D"],
      "explanation": " The method call of ServiceLoader.load() takes a parameter, making option B correct and option A incorrect. When using a Stream, you call Provider::get, making option D the other answer. Option C is incorrect because you don't need to call the get() method when using a loop."
    },
    {
      "number": 86,
      "answers": ["B"],
      "explanation": " The rules for determining the name include removing the extension, removing numbers, and changing special characters to periods (.). Additionally, we remove the version information from the end, which is 1.0.0-SNAPSHOT. Finally, we normalize the duplicate dots, which gives us option B: lizard.cricket."
    },
    {
      "number": 87,
      "answers": ["D"],
      "explanation": " The jar file format is the most common. The JMOD jmod format is used as well. Therefore, option D is correct."
    },
    {
      "number": 88,
      "answers": ["B"],
      "explanation": " Option B is correct because a service provider should not contain an exports directive. The service locator is used to reference any implementation exposed by provides."
    },
    {
      "number": 89,
      "answers": ["A"],
      "explanation": " The com.light module is a dependency for all the other modules but does not depend on them. Similarly, the com.animal module is a dependency for the two higher-level modules but does not depend on them. Finally, the com.plant module is a dependency for the com.worm module but does not depend on it. While the modules are not defined in this order, the question is about cyclic dependencies and not order of compilation. There is no cyclic dependency, making option A correct."
    },
    {
      "number": 90,
      "answers": ["C", "E"],
      "explanation": " The jdeps command outputs requires mandated java.base except when run in summary mode, making option C correct. Since this module is an implicit dependency in all modules, option E is also correct."
    }
  ]
}