{
  "answers": [
    {
      "number":1,
      "answers": ["A"],
      "explanation": "While the ArrayList is declared with an initial capacity of one element, it is free to expand as more elements are added. Each of the three calls to the add() method adds an element to the end of the ArrayList. The remove() method call deletes the element at index 2, which is Art. Therefore, option A is correct."
    },
    {
      "number": 2,
      "answers": ["B"],
      "explanation": "The array brackets, [], are not allowed to appear before the type, making the lions declaration incorrect. When using an array initializer with braces, {}, you are not allowed to specify the size separately. The size is inferred from the number of elements listed. Therefore, tigers and ohMy are incorrect. When you're not using an array initializer, the size is required. An empty array initializer is allowed. Option B is correct because only bears is legal."
    },
    {
      "number": 3,
      "answers": ["E"],
      "explanation": "When declaring a class that uses generics, you must specify a name for the formal type parameter. Java uses the standard rules for naming a variable or class. A question mark is not allowed in a variable name, making options A and C incorrect. While it is common practice to use a single uppercase letter for the type parameter, this is not required. It certainly isn't a good idea to use existing class names like the News class being declared here or the Object class built into Java. However, both are allowed, making option E the correct answer."
    },
    {
      "number": 4,
      "answers": ["B", "E"],
      "explanation": "Option B is one answer because line 26 does not compile. The ? wildcard cannot be used when instantiating a type on the right side of the assignment operator. The other lines do compile. Additionally, option E is correct because lines 28 and 29 use autoboxing. They convert a primitive to a wrapper object, in this case Double and Integer, respectively. Line 30 is correct and does not use autoboxing. It places a null reference as the Integer object."
    },
    {
      "number":5,
      "answers": ["C"],
      "explanation": "A two-dimensional array is declared by listing both sizes in separate pairs of brackets, []. Option C correctly shows this syntax."
    },
    {
      "number": 6,
      "answers": ["D"],
      "explanation": "The offer() method inserts an element at the end of the queue. This means the queue contains [snowball, minnie, sugar]. The peek() method returns the element at the front of the queue without removing it. Therefore, snowball is printed twice, but the queue remains with three elements. This matches option D."
    },
    {
      "number": 7,
      "answers": ["E"],
      "explanation": "Notice how there is unnecessary information in this description. The fact that patrons select books by name is irrelevant. The checkout line is a perfect example of a Queue. You need easy access to one end of the Queue for patrons to add themselves to the queue. You also need easy access for patrons to get off the queue when it is their turn. Since a LinkedList is a Queue, this narrows down the answer to options D, E, and F. The book lookup by ISBN is a lookup by key. You need a map for this. A HashMap is probably better here, but it isn't a choice. So the answer is option E, which does include both a Queue and a Map."
    },
    {
      "number": 8,
      "answers": ["B"],
      "explanation": "Line 8 attempts to store a String in an array meant for an int. Line 8 does not compile, and option B is correct."
    },
    {
      "number": 9,
      "answers": ["B"],
      "explanation": "Options C and D are incorrect because the method signature is incorrect. Unlike the equals() method, the method in Comparator<String> takes the type being compared as the parameters when using generics. Option A is a valid Comparator<String>. However, it sorts in ascending order by length. Option B is correct. If s1 is three characters and s2 is one character, it returns -2. The negative value says that s1 should sort first, which is correct, because you want the longest String first."
    },
    {
      "number": 10,
      "answers": ["B"],
      "explanation": "In Java, arrays are indexed starting with 0. Although it is unusual for the loop to start with 1, this does not cause an error. It does cause the code to output six lines instead of seven since the loop doesn't cover the first array element. Therefore, option B is correct."
    },
    {
      "number": 11,
      "answers": ["C"],
      "explanation": "Java talks about the Collections Framework, but the Map interface does not actually implement the Collection interface. TreeMap has different methods than the other options. It cannot fill in the blank, so option C is correct. The other options compile and print true at runtime."
    },
    {
      "number": 12,
      "answers": ["B", "F"],
      "explanation": "In Java, Arrays.binarySearch() returns a positive int, representing the index of a match if one is found. An int cannot be stored in a String variable, making option F one of the answers. When using the correct data type and searching for seed, we find it at index 1. Therefore, option B is the other answer."
    },
    {
      "number": 13,
      "answers": ["C"],
      "explanation": "As with a one-dimensional array, the brackets, [], must be after the type, making alpha and beta illegal declarations. For a multidimensional array, the brackets may be before and/or after the variable name. They do not need to be in the same place. Therefore, gamma, delta, and epsilon are correct. Finally, var can be used as a local variable but not with array brackets after it. The code would compile if it said var zeta and it was assigned an array of a specified type. Since three options are correct, the answer is option C."
    },
    {
      "number": 14,
      "answers": ["A"],
      "explanation": "First, the code creates an ArrayList of three elements. Then the list is transformed into a TreeSet. Since sets are not allowed to have duplicates, the set has only two elements. Remember that a TreeSet is sorted, which means that the first element in the TreeSet is 3. Therefore, option A is correct."
    },
    {
      "number": 15,
      "answers": ["D", "E"],
      "explanation": "Three dots in a row is a varargs parameter. While varargs is used like an array from within the method, it can only be used as a method parameter. This syntax is not allowed for a variable, causing a compiler error on line 5. Line 6 does not compile because linearSort() should be sort(). On line 7, the method name is also incorrect. The search() method should be binarySearch(). Finally, line 8 uses size() instead of length. Since there are four errors, option D is correct. If all these errors were corrected, original[0] would cause an exception because the array is empty. Therefore, option E is also correct."
    },
    {
      "number": 16,
      "answers": ["A", "D", "F"],
      "explanation": "Line 20 does not compile for a Map because it requires two generic types. Line 23 does not compile for a Set because the elements are unordered and do not have an index. This makes options D and F correct. Additionally, option A is correct because line 23 replaces the second element with a new value, making chars contain [a, c]. Then line 24 removes the first element, making it just [c]. There is only one element, but it is not the value b."
    },
    {
      "number": 17,
      "answers": ["E"],
      "explanation": "The Magazine class doesn't implement Comparable<Magazine>. It happens to implement the compareTo() method properly, but it is missing actually writing implements Comparable. Since TreeSet doesn't look to see if the object can be compared until runtime, this code throws a ClassCastException when TreeSet calls add(), so option E is correct."
    },
    {
      "number": 18,
      "answers": ["B"],
      "explanation": "Arrays begin with an index of 0. This array is a 3×3 array, making only indexes 0, 1, and 2 valid. All of the lines compile, but line 12 is the first to throw an ArrayIndexOutOfBoundsException at runtime. Therefore, option B is correct."
    },
    {
      "number": 19,
      "answers": ["D"],
      "explanation": "The generic declaration on line R is valid. It sets a constraint on the generic type used when declaring a Fur object. Lines S and T compile as they meet this constraint. However, line U has a problem since Sat does not extend Mammal. Since this line does not compile, option D is the answer."
    },
    {
      "number": 20,
      "answers": ["C"],
      "explanation": "Line 18 puts 3 in nums since it is the smaller value. Since a Set must have unique elements, line 19 does not add another value to nums. Line 20 adds the final value of 16. The set has a total of two elements, 3 and 16. A HashSet does not commit to an output order, making option C correct."
    },
    {
      "number": 21,
      "answers": ["B"],
      "explanation": "A Deque lets us add elements at both ends. The offer() method adds an element to the back of the queue. After line 7 completes, the queue contains 18 and 5 in that order. The push() method adds an element to the front of the queue. How rude! The element 13 pushes past everyone on the line. After line 8 completes, the queue now contains 13, 18, and 5, in that order. Then we get the first two elements from the front, which are 13 and 18, making option B correct."
    },
    {
      "number": 22,
      "answers": ["E", "F"],
      "explanation": "TreeMap and TreeSet sort as you insert elements. TreeMap sorts the keys and TreeSet sorts the objects in the set. This makes options E and F correct. Note that you have the option of having JellyBean implement Comparable, or you can pass a Comparator to the constructor of TreeMap or TreeSet. Option D is trying to trick you, as SortedArray is not a class or an interface in the Collections Framework."
    },
    {
      "number": 23,
      "answers": ["B"],
      "explanation": "Array indices start with 0, making options C and D incorrect. The length attribute refers to the number of elements in an array. It is 1 past the last valid array index. Therefore, option B is correct."
    },
    {
      "number": 24,
      "answers": ["B"],
      "explanation": "Options D, E, and F do not compile because only a wildcard can be used here. Since the method does not have any declared exceptions, it can only throw unchecked exceptions. Option B is correct because it is the only one that requires the elements of coll to be RuntimeException or any subclasses."
    },
    {
      "number": 25,
      "answers": ["D"],
      "explanation": "Options A and B show that the brackets, [], can be before or after the variable name and produce the same array. Option C specifies the same array the long way with two arrays of length 1. Option D is the answer because it is different from the others. It instead specifies an array of length 1 where that element is of length 2."
    },
    {
      "number": 26,
      "answers": ["D"],
      "explanation": "Java requires having a sorted array before calling the binarySearch() method. You do not have to call Arrays.sort to perform the sort, though. This array happens to already be sorted, so it meets the precondition. The target string of 'Linux' is the first element in the array. Since Java uses zero-based indexing, search is 0. The Arrays.mismatch() method returns -1 if the arrays are the same and returns the index of the first difference if they are not. In our example, mismatch1 is 0 because the first element differs, and mismatch2 is -1 because the arrays are the same. This makes option D the answer."
    },
    {
      "number": 27,
      "answers": ["D"],
      "explanation": "The Comic<S> interface declares a formal type parameter. This means that a class implementing it needs to specify this type. The code on line 21 compiles because the lambda reference supplies the necessary context, making option A incorrect. Option B declares a generic class. Although this doesn't tell us the type is Snoopy, it punts the problem to the caller of the class. The declaration of s2 on line 22 compiles because it supplies the type, making option B incorrect. The code on line 23 compiles because the SnoopyClass itself supplies the type, making option C incorrect. Option D has a problem. SnoopyClass and SnoopyComic appear similar. However, SnoopyComic refers to S. This type parameter exists in the interface. It isn't available in the class because the class has said it is using Snoopy as the type. Since the SnoopyComic class itself doesn't compile, the line with s4 can't instantiate it, and option D is the answer."
    },
    {
      "number": 28,
      "answers": ["C"],
      "explanation": "When implementing Comparable<Truck>, you implement the compareTo() method. Since this is an instance method, it already has a reference to itself and only needs the item it is comparing. Only one parameter is specified, and option C is correct. By contrast, the Comparator<Truck> interface uses the compare() method, and the method takes two parameters."
    },
    {
      "number": 29,
      "answers": ["B"],
      "explanation": "There is nothing wrong or tricky about this code. It correctly creates a seven-element array. The loop starts with index 0 and ends with index 6. Each line is correctly output. Therefore, option B is correct."
    },
    {
      "number": 30,
      "answers": ["A", "B"],
      "explanation": "Options E and F are incorrect because they do not compile. List is an interface and does not have a constructor. ArrayList has a constructor but not one that takes individual elements as parameters. Options C and D are incorrect because List.of() creates an immutable list. Trying to change one of its values causes an exception at runtime."
    },
    {
      "number": 31,
      "answers": ["F"],
      "explanation": "The Wash class takes a formal type parameter named T. Options A and E show the best ways to call it. These options declare a generic reference type that specifies the type is String. Option A uses local variable type inference, whereas option E uses the diamond syntax to avoid redundantly specifying the type of the assignment. Options B, C, and D show that you can omit the generic type in the reference and still have the code compile. You do get a compiler warning, scolding you for having a raw type. But compiler warnings do not prevent compilation. With the raw type, the compiler treats T as if it is of type Object. That is okay in this example because the only method we call is toString() implicitly when printing the value. Since toString() is defined on the Object class, we are safe, and options B, C, and D work. Since all can fill in the blank, option F is the answer."
    },
    {
      "number": 32,
      "answers": ["B"],
      "explanation": "Options A, C, and D represent 3×3 2D arrays. Option B is correct because it best represents the array in the code. It shows there are three different arrays of different lengths."
    },
    {
      "number": 33,
      "answers": ["B", "E"],
      "explanation": "The goal is to write code that sorts in descending order. Option A sorts ascendingly and option B sorts descendingly. Similarly, option C sorts ascendingly and option E sorts descendingly. Option D attempts to call the reverse() method, which is not defined. Therefore, options B and E are the answers."
    },
    {
      "number": 34,
      "answers": ["B"],
      "explanation": "When creating an array object, a set of elements or size is required. Therefore, lion and bear are incorrect. The brackets containing the size are required to be after the type, making ohMy incorrect. The only one that is correct is tiger, making option B the answer."
    },
    {
      "number": 35,
      "answers": ["C"],
      "explanation": "This code creates a two-dimensional array of size 1×2. Lines m1 and m2 assign values to both elements in the inner array. Line m3 attempts to reference the second element of the outer array. Since there is no such position, it throws an exception, and option C is correct."
    },
    {
      "number": 36,
      "answers": ["C"],
      "explanation": "All four of these return immutable collections. Options B and D take a varargs rather than a List, returning a List<List<Integer>> and Set<List<Integer>>, respectively. Option A returns a List, not a Set. Option C meets both our requirements and is the answer."
    },
    {
      "number": 37,
      "answers": ["C", "E"],
      "explanation": "The code sorts before calling the binarySearch() method, so it meets the precondition for that method. The target string of \"RedHat\" is not found in the sorted array. If it were found, it would be between the second and third elements. The rule is to take the negative index of where it would be inserted and subtract 1. It would need to be inserted as the third element. Since indexes are zero-based, this is index 2. We take the negative, which is –2, and subtract 1, giving -3. The target string of \"Mac\" is the second element in the sorted array. Since array indices begin with 0, the second position is index 1. This makes options C and E the answer."
    },
    {
      "number": 38,
      "answers": ["D"],
      "explanation": "Line x1 returns a Set of map entries. Set does not have a getKey() method, so line x2 does not compile, and option D is the answer."
    },
    {
      "number": 39,
      "answers": ["A", "C", "D"],
      "explanation": "The offerLast() and offer() methods insert an element at the back of the queue, while the offerFirst() method inserts the element at the front of the queue. This means the queue initially contains [snowball, sugar, minnie]. The poll() method returns the element at the front of the queue and removes it. In this case, it prints snowball, and the queue is reduced from three elements to [sugar, minnie]. Then, the removeFirst() method removes sugar, leaving the queue containing only [minnie]. Further, the queue becomes one smaller, and 1 is printed. Therefore, options A, C, and D are correct."
    },
    {
      "number": 40,
      "answers": ["B"],
      "explanation": "All of the variables point to a 4D array, except nums2b, which points to a 3D array. Don't create a 4D array in practice; it's confusing. The options show that the brackets, [], can be before or after the variable in any combination. Option B is the answer because nums2b points to a 3D array. It has only three pairs of brackets before the variable and none after. By comparison, nums2a has three pairs of brackets before the variable and the fourth pair of brackets after."
    },
    {
      "number": 41,
      "answers": ["C"],
      "explanation": "Option E is the longest way to specify this code. Options A and D shorten it by using the diamond operator (<>). Options A and B shorten it using var. Option C is the answer since it does not compile because the diamond operator cannot be used on the left side of the assignment."
    },
    {
      "number": 42,
      "answers": ["C"],
      "explanation": "The Arrays.compare() method looks at each element in turn. Since the first elements are different, we get the result of comparing them. In this case, we get a positive number because 3 is larger than 2 and option C is correct."
    },
    {
      "number": 43,
      "answers": ["E"],
      "explanation": "List.of() makes an immutable list. Attempting to sort throws an exception, so option E is the answer. If we were calling Arrays.asList() instead, option C would be the answer because it is the only option to sort ascendingly by length."
    },
    {
      "number": 44,
      "answers": ["A"],
      "explanation": "Line 13 adds excelsior to the double-ended queue. Line 14 checks if an element is there but does not change it. Line 15 adds edwin to the front. Since line 16 removes from the back, we are left with [edwin] and option A is the answer."
    },
    {
      "number": 45,
      "answers": ["B"],
      "explanation": "This one is tricky since the array brackets, [], are split up. This means that bools is a 3D array reference. The brackets both before and after the variable name count. For moreBools, it is only a 2D array reference because there are only two pairs of brackets next to the type. In other words, boolean[][] applies to both variables. Then bools gets another dimension from the brackets right after the variable name. However, moreBools stays at 2D, making option B correct."
    },
    {
      "number": 46,
      "answers": ["E"],
      "explanation": "A custom sort order is specified using a Comparator to sort in descending order. However, this Comparator is not passed when searching. When a different sort order is used for searching and sorting, the result is undefined. Therefore, option E is correct."
    },
    {
      "number": 47,
      "answers": ["C"],
      "explanation": "The binarySearch() method requires a sorted array in order to return a correct result. If the array is not sorted, the results of a binary search are undefined, making option C the answer."
    },
    {
      "number": 48,
      "answers": ["B", "F"],
      "explanation": "The <> is known as the diamond operator. Here, it works as a shortcut to avoid repeating the generic type twice for the same declaration. On the right side of the expression, this is a handy shortcut. Java still needs the type on the left side, so there is something to infer. Positions Q and S are on the right side, making option B correct. In this question, the generic type is never specified, so it is Object. Since it is not String, option F is correct."
    },
    {
      "number": 49,
      "answers": ["B", "D"],
      "explanation": "Since no arguments are passed from the command line, this creates an empty array. Sorting an empty array is valid and results in an empty array printed on line 6. Then line 7 attempts to access an element of the empty array and throws an ArrayIndexOutOfBoundsException. Therefore, options B and D are correct."
    },
    {
      "number": 50,
      "answers": ["A"],
      "explanation": "The generic declaration on line R is not valid due to the question mark (?) wildcard. While a question mark is allowed on the left side of a declaration, it is not allowed when specifying a constraint on a class. Since line R does not compile, option A is the answer."
    },
    {
      "number": 51,
      "answers": ["E"],
      "explanation": "Line 6 assigns an int to a cell in a 2D array. This is fine. Line 7 casts to a general Object[]. This is dangerous, but legal. Why is it dangerous, you ask? That brings us to line 8. The compiler can't protect us from assigning a String to the int[] because the reference is more generic. Therefore, line 8 throws an ArrayStoreException because the type is incorrect, and option E is correct. You couldn't have assigned an int on line 8 either because obj[3] is really an int[] behind the scenes and not an int."
    },
    {
      "number": 52,
      "answers": ["D"],
      "explanation": "TreeSet does not allow null values because it compares the values when they are added, leading to a NullPointerException. A HashSet does support null values, although you can only have one since HashSet guarantees uniqueness. ArrayList and LinkedList both support any number of null entries. Since three of the four collections allow inserting null values, option D is correct."
    },
    {
      "number": 53,
      "answers": ["B"],
      "explanation": "Unfortunately, you do have to memorize two facts about sort order. First, numbers sort before letters. Second, uppercase sorts before lowercase. Since the first value is 3 and the last is three, option B is correct."
    },
    {
      "number": 54,
      "answers": ["C"],
      "explanation": "Since the brackets in the declaration are before the variable names, the variable type boolean[][][] applies to both variables. Therefore, both bools and moreBools can reference a 3D array and option C is correct."
    },
    {
      "number": 55,
      "answers": ["D"],
      "explanation": "Line 25 does not compile, making option D the answer. On an ArrayList, the method to get the number of elements is size(). The length() method is used for a String or StringBuilder. If this were fixed, the answer would be option E. Line 23 empties the ArrayList. Then line 24 attempts to access an index that is not present."
    },
    {
      "number": 56,
      "answers": ["C"],
      "explanation": "The ? is an unbounded wildcard. It is used in variable references but is not allowed in declarations. In a static method, the type parameter specified inside the <> is used in the rest of the method declaration. Since it needs an actual name, options A and B are incorrect. We need to specify a type constraint so that we can call the add() method. Regardless of whether the type is a class or interface, Java uses the extends keyword for generics. Therefore, option D is incorrect, and option C is the answer."
    },
    {
      "number": 57,
      "answers": ["D"],
      "explanation": "Java requires having a sorted array before calling the binarySearch() method. Since the array is not sorted, the result is undefined, and option D is correct. It may happen that you get 1 as the result, but this behavior is not guaranteed. You need to know for the exam that this is undefined even if you happen to get the “right” answer."
    },
    {
      "number": 58,
      "answers": ["A"],
      "explanation": "A multidimensional array is created with multiple sets of size parameters. Line 11 should be char[] ticTacToe = new char[3][3];. Therefore, option A is the answer."
    },
    {
      "number": 59,
      "answers": ["C"],
      "explanation": "On a stream, the filter() method only keeps values matching the lambda. The removeIf() does the reverse on a Collection and keeps the elements that do not match. In this case, that is Austin and Boston, so option C is correct."
    },
    {
      "number": 60,
      "answers": ["C"],
      "explanation": "The names.length value is the number of elements in the array. The last valid index in the array is one less than names.length. Therefore, the code throws an ArrayIndexOutOfBoundsException, and option C is correct."
    },
    {
      "number": 61,
      "answers": ["A"],
      "explanation": "An ArrayList automatically expands when it is full, while an array does not. The other three statements are true for both arrays and ArrayLists."
    },
    {
      "number": 62,
      "answers": ["C"],
      "explanation": "The forEach() method that takes one parameter is defined on the Collection interface. A Map needs two parameters, so option C is the answer."
    },
    {
      "number": 63,
      "answers": ["G"],
      "explanation": "Option G is correct because wildcard must be used here. Option A is incorrect because coll could be any type, which doesn't necessarily allow anything to be added. Option B is incorrect because neither add() method compiles. Option C is incorrect as the second add() method does not compile because broader types than the generic allows are a problem when adding to coll."
    },
    {
      "number": 64,
      "answers": ["A", "D"],
      "explanation": "Lines 35–38 create a Map with three key/value pairs. Lines 40–43 sort just the values ascendingly by year. Lines 45 and 48 show you can assign the Integer values to an int via unboxing or an Integer directly. Line 46 shows the values are properly sorted, making option A correct. Finally, line 48 throws an exception because sorted.size() returns 3 and the maximum index in the List is 2. This makes option D correct as well."
    },
    {
      "number": 65,
      "answers": ["C"],
      "explanation": "Arrays are indexed using numbers, not strings, and array indexes are zero-based, making option C the answer."
    },
    {
      "number": 66,
      "answers": ["B"],
      "explanation": "This code shows a proper implementation of Comparable. It compares the magazine names in alphabetical order. Remember that uppercase letters sort before lowercase letters. Since Newsweek starts with uppercase, option B is correct."
    },
    {
      "number": 67,
      "answers": ["B"],
      "explanation": "The method calls size(). This method is available on Collection and all classes that extend/implement it. Therefore, option B is correct."
    },
    {
      "number": 68,
      "answers": ["D"],
      "explanation": "While it is unusual for the loop to start with 1, this does not cause an error. What does cause an error is the loop ending at data.length because the <= operator is used instead of the < operator. The last array index is 6, not 7. On the last iteration of the loop, the code throws an ArrayIndexOutOfBoundsException. Therefore, option D is correct."
    },
    {
      "number": 69,
      "answers": ["C"],
      "explanation": "This array has two elements, making listing.length output 2. While each array element does not have the same size, this does not matter because we are only looking at the first element. The first element has one. This makes option C the answer."
    },
    {
      "number": 70,
      "answers": ["E"],
      "explanation": "The addFirst() and addLast() methods are on the Deque interface. Since the q variable is of type Queue, these methods do not compile, and option E is the answer."
    },
    {
      "number": 71,
      "answers": ["D"],
      "explanation": "Line 13 creates a fixed-size list. While we are using var, the type is List<Integer>. Line 14 successfully changes the contents of the list to [3, null, 4]. Line 15 automatically unboxes to the primitive 3. Line 16 has a problem. The list has a null value at index 1. This cannot be unboxed to a primitive and throws a NullPointerException. Therefore, option D is the answer."
    },
    {
      "number": 72,
      "answers": ["F"],
      "explanation": "Option C is missing the logic to sort descendingly, printing alpha at runtime. This leaves option F, which correctly sorts the elements, reverses them, and prints gamma at runtime."
    },
    {
      "number": 73,
      "answers": ["B", "C"],
      "explanation": "Array indexes begin with 0. FirstName is the name of the class, not an argument. The first argument is Wolfie, making option B correct. There is not a second argument, and the array is of size 1, so option C is also correct."
    },
    {
      "number": 74,
      "answers": ["C"],
      "explanation": "Line 11 creates an ArrayList with a generic type Object rather than Integer. This is allowed since we aren't trying to assign any of the values to an int or Integer after getting them from pennies. This gives us the list [1, 2, 3, 4]. The next trick is that there are two remove() methods available on ArrayList. One removes an element by index and takes an int parameter. The other removes an element by value and takes an Object. On line 16, the int primitive is a better match, and the element with index 2 is removed, which is the value of 3. At this point, we have [1, 2, 4]. Then on line 17, the other remove() method is called because we are explicitly using the wrapper object. This deletes the object that is equal to 1, and now we have [2, 4]. This makes option C the answer."
    },
    {
      "number": 75,
      "answers": ["C", "D"],
      "explanation": "The code will output 0 when the array is sorted in ascending order since flower will be first. Option C is the most straightforward way of doing this, making it one of the answers. Reversing the order of the variables or adding a negative sign sorts in descending order, making options A, B, E, F, and G incorrect. Doing both is a complicated way of sorting in ascending order, making option D the other correct answer."
    },
    {
      "number": 76,
      "answers": ["B"],
      "explanation": "The elements of the array are of type String rather than int. Therefore, we use alphabetical order when sorting. The character 1 sorts before the character 9, alphabetically, making option B the answer."
    },
    {
      "number": 77,
      "answers": ["F"],
      "explanation": "Line 11 correctly creates a 2D array. The next three lines correctly assign a value to an array element. Line 15 correctly outputs 3 in a row!, making option F correct."
    },
    {
      "number": 78,
      "answers": ["A", "D", "F"],
      "explanation": "Line 40 does not compile since getOrDefault() requires two parameters. This makes option A the first answer. The rest of the code does compile. Option D is the next answer because getOrDefault() returns the value from the map when the key is present. Finally, option F is correct because getOrDefault() returns the second parameter when the key is not present."
    },
    {
      "number": 79,
      "answers": ["E"],
      "explanation": "Lines 18 and 19 create a list with five elements. Line 20 makes a set with the same five elements. Line 21 does not change the contents of the set since sets must have unique elements. The loop on line 22 tries to delete elements but instead throws a ConcurrentModificationException, making option E the answer."
    },
    {
      "number": 80,
      "answers": ["C"],
      "explanation": "Options D, E, and F do not compile because only a wildcard can be used here. Option C is correct because all the types being added are of type Exception or direct subclasses."
    }
  ]

}