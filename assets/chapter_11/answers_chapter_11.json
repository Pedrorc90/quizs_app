{
  "answers": [
    {
      "number": 1,
      "answers": [
        "A",
        "E",
        "F"
      ],
      "explanation": "Oracle defines a locale as a geographical, political, or cultural region, making options A, E, and F correct. A local address and city are too granular for a locale. Also, time zones often span multiple locales."
    },
    {
      "number": 2,
      "answers": [
        "B"
      ],
      "explanation": "While it is traditional to include the year when outputting a date, it is not required. This code correctly prints the month followed by a decimal point. After the decimal point, it prints the day of the month followed by the hours and minutes. Happy Pi Day! For these reasons, option B is correct."
    },
    {
      "number": 3,
      "answers": [
        "E"
      ],
      "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case is the fr language. It doesn't find it, so it moves on to the default locale, en_US, which it does find, making option E correct."
    },
    {
      "number": 4,
      "answers": [
        "C",
        "E"
      ],
      "explanation": "A CompactNumberFormat rounds to the nearest whole number within the three-digit range, so the first line prints 2 million, making option E correct. The second line prints 2M, since SHORT is used as the STYLE by default, making option C correct."
    },
    {
      "number": 5,
      "answers": [
        "F"
      ],
      "explanation": "The code compiles but the first line throws an exception at runtime, making option F correct. The string sent to the parse() method contains a time component, but ISO_LOCAL_DATE is used as the formatter."
    },
    {
      "number": 6,
      "answers": [
        "F"
      ],
      "explanation": "Options A and B are incorrect because formatDate() is not a valid method name in DateTimeFormatter. Option E is incorrect because the code compiles if either option C or D is used. Both options C and D will produce an exception at runtime, though, as the date pattern is invalid. In particular, the apostrophe in o'clock should be escaped. Option C is also incorrect because there is no hour value h for a LocalDate. If the pattern string was corrected with o''clock, then option D would be correct and print March at 5 o'clock at runtime."
    },
    {
      "number": 7,
      "answers": [
        "B"
      ],
      "explanation": "LocalDate starts counting months from 1, so month 2 is February. This rules out options A and C. The pattern specifies that the date should appear before the month, making option B correct."
    },
    {
      "number": 8,
      "answers": [
        "A",
        "C"
      ],
      "explanation": "In Java, a locale can be represented by a language code in lowercase, or a language and country code, with language in lowercase and country in uppercase. For these reasons, options A and C are correct. Options B, D, and E are incorrect because the lowercase language must be before the uppercase country. Option F is incorrect because the language is missing."
    },
    {
      "number": 9,
      "answers": [
        "F"
      ],
      "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case is the fr_CH language and country. It doesn't find Colors_fr_CH.properties, so it moves on to the locale with just a language code fr. It also does not find Colors_fr.properties. It then moves on to the default locale, it_CH, checking Colors_it_CH.properties, but there is still no match. It drops the country code and checks it for Colors_it.properties, but still doesn't find a match. Finally, it checks for a Colors.properties file but since that's not an option, it fails. The result is that a MissingResourceException is thrown at runtime, making option F correct."
    },
    {
      "number": 10,
      "answers": [
        "C"
      ],
      "explanation": "The code compiles, so option D is incorrect. In this sample, the default locale is set to US, while the default locale format is set to GERMANY. Neither is used for formatting the value, as getCurrencyInstance() is called with UK as the locale. For this reason, the £ symbol is used, making option C correct."
    },
    {
      "number": 11,
      "answers": [
        "D"
      ],
      "explanation": "There is a DateTimeFormatter class, but not a DateFormatter class. The DateTimeFormatter class is used for formatting dates, times, or both. Since the provided code does not compile, nothing can fill in the blank to make the code print 2022-01-15, and option D is the answer."
    },
    {
      "number": 12,
      "answers": [
        "D"
      ],
      "explanation": "The getBundle() does not find Cars_de_DE.properties or Cars_de.properties, so it moves on to the default locale. Since Cars_en.properties is available, it will use this file, falling back to Cars.properties if any values are not available. Therefore, it selects engine and horses from the first file, and country from the second file, printing engine 241 earth and making option D correct."
    },
    {
      "number": 13,
      "answers": [
        "F"
      ],
      "explanation": "The getBundle() method matches Cars_fr_FR.properties. It will then fall back to Cars_fr.properties (which does not exist) and Cars.properties if the value is not available. For this reason, the first and third values would be France and moteur. While the second value horses is in the default locale, it is not available if the requested locale has been found. As a result, the code throws a MissingResourceException, making option F the answer."
    },
    {
      "number": 14,
      "answers": [
        "A"
      ],
      "explanation": "The getBundle() method matches Cars_fr_FR.properties. It will then fall back to Cars_fr.properties (which does not exist) and Cars.properties if the value is not available. For this reason, the first value printed is moteur from Cars.properties, while the next two values printed are autoroute and France from Cars_fr_FR.properties, making option A correct."
    },
    {
      "number": 15,
      "answers": [
        "B",
        "D",
        "F"
      ],
      "explanation": "There are no get() or of() methods in Locale. You can define a Locale using a constructor, making option B correct. You can also use a Locale.Builder, making option D correct. Finally, you can use a built-in constant, making option F correct."
    },
    {
      "number": 16,
      "answers": [
        "A"
      ],
      "explanation": "Java starts out by looking for a properties file with the requested locale, which in this case is the zh_CN language and country. It doesn't find it, so it moves onto the locale with just a language code zh, which it also does not find. It then moves on to the default locale en_US, but there is still no match. It drops the country code and does find a match with en, making option A correct."
    },
    {
      "number": 17,
      "answers": [
        "D"
      ],
      "explanation": "For dates, a lowercase m means minute while an uppercase M means month. This eliminates options A and C. A lowercase h means hour. Therefore, option B is incorrect, and option D is the answer."
    },
    {
      "number": 18,
      "answers": [
        "F"
      ],
      "explanation": "A CompactNumberFormat rounds to the nearest whole number within the three-digit range, so the numeric value printed is 123. Since the SHORT style is selected, the output is 123K, making option F correct."
    },
    {
      "number": 19,
      "answers": [
        "B",
        "D"
      ],
      "explanation": "Options B and D correctly print the same string value in the specified format. Option A is incorrect because <06.92> is printed instead of <06.9>. Options C and E are incorrect, because (among other things) commas are printed as part of both of the first two values. Option F is incorrect because <2.1> <6.9> is printed instead of <02.1> <06.9>."
    },
    {
      "number": 20,
      "answers": [
        "C",
        "D"
      ],
      "explanation": "In Java, a locale can be represented by a language code in lowercase, or a language and country code, with language in lowercase and country in uppercase. Option C is invalid because both values are lowercase. Option D is invalid because the value is in uppercase. The rest of the options are valid locale formats."
    },
    {
      "number": 21,
      "answers": [
        "D"
      ],
      "explanation": "The DateTimeFormatter is created with ofLocalizedDate(). It knows how to format date fields but not time fields. Line 18 is fine because a LocalDate clearly has date fields. Line 19 is also fine. Since a LocalDateTime has both date and time fields, the formatter just looks at the date fields. Line 20 is a problem. A LocalTime object does not have any date fields so the formatter throws an UnsupportedTemporalTypeException, making option D the answer."
    },
    {
      "number": 22,
      "answers": [
        "B"
      ],
      "explanation": "The code compiles, so option D is incorrect. While three distinct locale values are set, the one that is used for formatting text is Category.FORMAT. For this reason, the GERMANY locale is used to format the data with the € symbol, making option B correct."
    },
    {
      "number": 23,
      "answers": [
        "D"
      ],
      "explanation": "The date/time pattern uses single quotes to escape the date/time values, meaning the output is yyyy-MM for all valid inputs. For this reason, option D is correct. If the single quotes were removed, then 2022-03 2022-01 would be the correct output."
    },
    {
      "number": 24,
      "answers": [
        "D"
      ],
      "explanation": "The method creates a resource bundle using a builder but never sets it. Since we don't know the default locale of the code, the answer depends on where it is executed, making option D correct."
    },
    {
      "number": 25,
      "answers": [
        "A"
      ],
      "explanation": "This code sets the default locale to English and then tries to get a resource bundle for container. It finds the resource bundle container_en.properties as the most specific match. Both keys are found in this file, so option A is the answer."
    },
    {
      "number": 26,
      "answers": [
        "E"
      ],
      "explanation": "The Locale constructor that takes a single argument expects a language code, not a concatenation of language and region codes. Therefore, the language is set as en_us, not en, with no region code set. Since no properties files match the language en_us, the default container.properties is used. Since type is not found in this properties file, a MissingResourceException is thrown at runtime."
    },
    {
      "number": 27,
      "answers": [
        "E"
      ],
      "explanation": "Both LocalDate and DateTimeFormatter have a format() method. While it is tricky, you do need to know that the format() method can be called on either object. Therefore, option E is the answer."
    },
    {
      "number": 28,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles, so option E is incorrect. Java starts out by looking for a properties file with the requested locale, which in this case is the fr language. It doesn't find Forest_fr.properties, so it moves onto the default locale en. It also doesn't find Forest_en.properties. It settles on Forest.properties without throwing an exception, so option F is incorrect. The first argument to MessageFormat.format() should be a pattern String value. Since trees is sent, the output of the formatting string is trees, making option A correct. If rb.getString(\"trees\") was passed instead of just trees, then the output would be evergreen pretty."
    },
    {
      "number": 29,
      "answers": [
        "D"
      ],
      "explanation": "The format of the pattern is incorrect. You can't just put literal text in there without escaping it. Most of the characters of Holiday: are not defined formatting symbols. The code throws an IllegalArgumentException, so option D is correct."
    },
    {
      "number": 30,
      "answers": [
        "E"
      ],
      "explanation": "The code does not compile because the first formatter requires both a Locale and a Style. You can omit both values, but not one."
    }
  ]
}