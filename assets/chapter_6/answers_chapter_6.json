{
  "answers": [
    {
      "number": 1,
      "answers": [
        "F"
      ],
      "explanation": "The source is the first operation, and the terminal operation comes last, making option F the answer. You need to know this terminology."
    },
    {
      "number": 2,
      "answers": [
        "B"
      ],
      "explanation": "The lambda expression s -> true is valid, making options A, C, and D incorrect. Parentheses, (), are not required on the left side if there is only one variable. Braces, {}, are not required if the right side is a single expression. Parameter data types are only required if the data type for at least one parameter is specified; otherwise, none are required. The remaining choice, the arrow operator, ->, is required for all lambda expressions, making option B the correct answer."
    },
    {
      "number": 3,
      "answers": [
        "C"
      ],
      "explanation": "The Supplier functional interface does not take any inputs, while the Consumer functional interface does not return any data. This behavior extends to the primitive versions of the functional interfaces, making option C the correct answer. Option A is incorrect because IntConsumer takes a value, while LongSupplier returns a value. Options B and D are incorrect because Function and UnaryOperator both take an input and produce a value."
    },
    {
      "number": 4,
      "answers": [
        "A",
        "E"
      ],
      "explanation": "The UnaryOperator and BiFunction return a generic argument, such as Double, making options A and E correct. Option B is incorrect because all predicate functions return boolean. Option C is incorrect because BiOperator does not exist in the java.util.function package. The correct name is BinaryOperator. Option D is incorrect because all consumer functions return void. Finally, option F is incorrect because BiSupplier does not exist in the java.util.function package. Supplier functions return values, and Java does not support methods with more than one return type."
    },
    {
      "number": 5,
      "answers": [
        "B"
      ],
      "explanation": "The stream pipeline is correct and filters all values out that are ten characters or smaller. Only San Francisco is long enough, so c is 1. The stream() call creates a new object, so stream operations do not affect the original list. Since the original list is still three elements, option B is correct."
    },
    {
      "number": 6,
      "answers": [
        "B",
        "C",
        "E"
      ],
      "explanation": "Interface X is tricky. If it returned a boolean primitive, option A would be correct, as Predicate returns a boolean. However, it returns a wrapper object, so it has to be a Supplier, making option B the answer instead. We can tell interface Y is a Comparator because it returns a primitive int, not an object like Integer, and interface Z is a Consumer because it returns void. This makes options C and E the final two answers."
    },
    {
      "number": 7,
      "answers": [
        "C"
      ],
      "explanation": "Option A is incorrect because a pipeline still runs if the source doesn't generate any items and the rest of the pipeline is correct. Granted, some of the operations have nothing to do, but control still passes to the terminal operation. Option B is incorrect because intermediate operations are optional. Option C is the answer. The terminal operation triggers the pipeline to run. Option D is incorrect because the code would not compile at all if the version of Java were too old."
    },
    {
      "number": 8,
      "answers": [
        "A"
      ],
      "explanation": "The LongSupplier interface does not take any input, making option D incorrect. It also uses the method name getAsLong(). The rest of the functional interfaces all take a long value but vary on the name of the abstract method they use. LongFunction contains apply() and LongPredicate contains test(), making options B and C, respectively, incorrect. That leaves us with LongConsumer, which contains accept(), making option A the correct answer."
    },
    {
      "number": 9,
      "answers": [
        "F"
      ],
      "explanation": "The correct method to obtain an equivalent sequential stream of an existing stream is sequential(), which is inherited by any class that implements BaseStream<T>. Since this isn't an option, option F is correct. Note that unordered() creates a stream that can be evaluated in any order, but it can still be processed in a sequential or parallel stream."
    },
    {
      "number": 10,
      "answers": [
        "C"
      ],
      "explanation": "Since we are concatenating two infinite streams, concat() creates an infinite stream. The limit() method turns it into a finite stream by ignoring all but the first three values of odd. Adding 1, 3, and 5 gives us 9, making option C the answer."
    },
    {
      "number": 11,
      "answers": [
        "B"
      ],
      "explanation": "Option A is incorrect because the lambda expression is missing a semicolon (;) at the end of the return statement. Option C is incorrect because the local variable test is used without being initialized. Option D is also incorrect. The parentheses are required on the left side of the lambda expression when there is more than one value or a data type is specified. Option B is the correct answer and the only valid lambda expression."
    },
    {
      "number": 12,
      "answers": [
        "B",
        "D"
      ],
      "explanation": "The second line throws a NullPointerException when you pass a null reference to the of() method. The others compile and run successfully, making option B correct. The first and third lines return false because they represent an empty Optional. This makes option D the other answer."
    },
    {
      "number": 13,
      "answers": [
        "D"
      ],
      "explanation": "Both are functional interfaces in the java.util.function package, making option A true. Additionally, both lack parameters, making option B true. The major difference between the two is that Supplier<Double> takes the generic type Double, while the other does not take any generic type and instead uses the primitive double. For this reason, options C and E are true statements. For Supplier<Double> in option C, remember that the returned double value can be implicitly autoboxed to Double. Option D is the correct answer. Lambdas for Supplier<Double> can return a null value since Double is an object type, while lambdas for DoubleSupplier cannot; they can only return primitive double values."
    },
    {
      "number": 14,
      "answers": [
        "C"
      ],
      "explanation": "The first line that contains the lambda expression will actually compile with any of the functional interfaces listed in the options. The stream operation, though, will compile only if ToIntFunction<Integer> is used. It requires this functional interface, which takes a generic argument and returns int. For this reason, option C is correct. Option F is incorrect because sum() on an IntStream returns an int, not an OptionalInt. Note that the peek() operations in this stream have no effect."
    },
    {
      "number": 15,
      "answers": [
        "E"
      ],
      "explanation": "Option A is incorrect because anyMatch() takes a Predicate and returns a boolean. Option B is incorrect because findAny() returns an Optional, not a primitive. Option C is incorrect because there is no first() method available as a terminal operation. Option D is tempting because there is a min() method. However, since we are working with a Stream (not a primitive stream like IntStream), this method requires a Comparator as a parameter. Therefore, option E is the answer."
    },
    {
      "number": 16,
      "answers": [
        "D"
      ],
      "explanation": "Line 8 does not compile. String::new is a constructor reference. This constructor reference is equivalent to writing the lambda () -> new String(). It participates in deferred execution. When it is executed later, it will return a String. It does not return a String on line 8, though. The method reference is a Supplier<String>, which cannot be stored in list. Since the code does not compile, option D is correct."
    },
    {
      "number": 17,
      "answers": [
        "C"
      ],
      "explanation": "The lambda (s,p) -> s+p takes two arguments and returns a value. For this reason, options A and B are incorrect because BiConsumer does not return any values. Option E is also incorrect, since Function takes only one argument and returns a value. This leaves us with options C and D, which both use BiFunction, which takes two generic arguments and returns a generic value. Option D is incorrect because the data type of the unboxed sum s+q is int, and int cannot be both autoboxed and implicitly cast to Double. Option C is correct. The sum s+p is of type double, and double can be autoboxed to Double."
    },
    {
      "number": 18,
      "answers": [
        "D"
      ],
      "explanation": "The word reduction is used with streams for a terminal operation, so options A, B, and C are incorrect. Option E describes a valid terminal operation like anyMatch(), but is not a reduction. Option D is correct because a reduction has to look at each element in the stream to determine the result."
    },
    {
      "number": 19,
      "answers": [
        "A"
      ],
      "explanation": "The filter() method either passes along a given element or doesn't, making options D, E, and F incorrect. The flatMap() method doesn't pass along any elements for empty streams. For nonempty streams, it can map each element to multiple new elements, making option C incorrect. This leaves us with the map() method, which passes exactly one element for each input, making option A the answer."
    },
    {
      "number": 20,
      "answers": [
        "A",
        "B",
        "D"
      ],
      "explanation": "To begin with, ToDoubleBiFunction<T,U> takes two generic inputs and returns a double value. Option A is correct because it takes an Integer and Double and returns a Double value that can be implicitly unboxed to double. Option B is correct because long can be implicitly cast to double. While we don't know the data types for the input arguments, we know that some values, such as using Integer for both, will work. Option C cannot be assigned and does not compile because the variable v is of type Object and Object does not have a length() method. Option D is correct. The variable y could be declared Double in the generic argument to the functional interface, making y/z a double return value. Option E is not correct because the lambda only has one parameter. Finally, option F is incorrect because the interface uses the class Double rather than primitive double."
    },
    {
      "number": 21,
      "answers": [
        "C"
      ],
      "explanation": "The correct method to obtain an equivalent parallel stream of an existing stream is parallel(), which is inherited by any class that implements BaseStream<T>. For this reason, option C is correct."
    },
    {
      "number": 22,
      "answers": [
        "A"
      ],
      "explanation": "The lambda is a Function<Integer, ArrayList>. We need a constructor reference that uses the new keyword where a method name would normally go in a method reference. It can implicitly take zero or one parameter just like a method reference. In this case, we have one parameter, which gets passed to the constructor. Option A is correct. Options B, C, and D use syntax that is not supported with method references."
    },
    {
      "number": 23,
      "answers": [
        "C"
      ],
      "explanation": "The average() method returns an OptionalDouble. This reflects that it doesn't make sense to calculate an average when you don't have any numbers. Similarly, max() returns an OptionalDouble because there isn't a maximum of no number. By contrast, counting without any numbers gives the long number 0 and summing gives the double number 0.0. Since only two methods match the desired return type, option C is correct."
    },
    {
      "number": 24,
      "answers": [
        "D",
        "E"
      ],
      "explanation": "The BiPredicate interface takes two generic arguments and returns a boolean value. Next, DoubleUnaryOperator and IntUnaryOperator exist and transform values of type double and int, respectively. Last, ToLongFunction takes a generic argument and returns a long value. That leaves options D and E, which are the answers. Remember Object is abbreviated to Obj in the built-in functional interfaces."
    },
    {
      "number": 25,
      "answers": [
        "A"
      ],
      "explanation": "The findAny() method can return the first, last, or any element of the stream, regardless of whether the stream is serial or parallel. While on serial streams this is likely to be the first element in the stream, on parallel streams the result is less certain. For this reason, option A is the correct answer."
    },
    {
      "number": 26,
      "answers": [
        "C"
      ],
      "explanation": "The result of the source and any intermediate operations are chained and eventually passed to the terminal operation. The terminal operation is where a result with a type other than stream is possible, making option C correct."
    },
    {
      "number": 27,
      "answers": [
        "C"
      ],
      "explanation": "The groupingBy() collector always returns a Map (or a specific implementation class of Map), so options D, E, and F are incorrect. The other two are definitely possible. To get one, you can group using a Function that returns an Integer such as s.collect(groupingBy(String::length)). To get the other, you need to group using a Function that returns a Boolean and specify the type, such as s.collect(groupingBy(String::isEmpty, toCollection(HashSet::new))). Therefore, option C is correct."
    },
    {
      "number": 28,
      "answers": [
        "F"
      ],
      "explanation": "The flatMap() method works with streams rather than collections. Line 18 is problematic because the return value is not a stream. Since the code does not compile, option F is correct."
    },
    {
      "number": 29,
      "answers": [
        "E"
      ],
      "explanation": "Since no generic type is specified, list is a LinkedList<Object>. Line w compiles because no generic type is specified. However, Java allows you to operate on a stream only once. The final line of code throws an IllegalStateException because the stream has already been used up, making option E correct."
    },
    {
      "number": 30,
      "answers": [
        "D"
      ],
      "explanation": "The code does not compile, so options A, B, and E are incorrect. The IntUnaryOperator functional interface is not generic, so the argument IntUnaryOperator<Integer> in the takeTicket() does not compile, making option D the correct answer. The lambda expression compiles without issue, making option C incorrect. If the generic argument <Integer> was dropped from the argument declaration, the class would compile without issue and output 51 at runtime, which would make option B the correct answer."
    },
    {
      "number": 31,
      "answers": [
        "A",
        "C",
        "E"
      ],
      "explanation": "Options A, C, and E are correct because they are the precise requirements for Java to perform a concurrent reduction using the collect() method, which takes a Collector argument. Recall from your studies that a Collector is considered concurrent and unordered if it has the Collector.Characteristics enum values CONCURRENT and UNORDERED, respectively. The rest of the options are not required for a parallel reduction."
    },
    {
      "number": 32,
      "answers": [
        "C",
        "E"
      ],
      "explanation": "While it is common for a Predicate to have a generic type, it is not required. However, it is treated like a Predicate of type Object if the generic type is missing. Since startsWith() does not exist on Object, line 28 does not compile. Line 34 would be a correct lambda declaration in isolation. However, it uses the variable s, which is already taken by the main() method parameter. This causes a compiler error on line 34. These are the only two compiler errors, making option C correct. If Predicate were changed to Predicate<String> and lambda variable were changed to x, then the Consumer would in fact print pink, making option E the other answer."
    },
    {
      "number": 33,
      "answers": [
        "A"
      ],
      "explanation": "Option A is the correct answer because BiPredicate takes two generic types and returns a primitive boolean value. Options B and E are incorrect, since CharSupplier and TriDoublePredicate do not exist. Option C is also incorrect, since LongFunction takes a primitive long value and returns a generic type. Finally, option D is incorrect because UnaryOperator takes a generic type and returns a generic value."
    },
    {
      "number": 34,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "An accumulator in a serial or parallel reduction should be associative and stateless. In a parallel reduction, problematic accumulators tend to produce more visible errors. Option A is not associative, since (a-b)-c is not the same as a-(b-c) for all values a, b, and c. Options C and D are incorrect because they represent stateful lambda expressions, which should be avoided especially on parallel streams. In particular, option C could return different results each time it is run. Option F doesn't even compile, since the return type is a boolean, not an Integer. That leaves us with the correct answers, options B and E. While these accumulators may not seem useful, they are both stateless and associative, which meets the qualifications for performing a reduction."
    },
    {
      "number": 35,
      "answers": [
        "D"
      ],
      "explanation": "Options A and C do not compile because there are no isNotNull() or forEach() methods in the Optional class. The Optional class does have an isPresent() method that doesn't take any parameters, making option B incorrect since it is used with a parameter. The method returns a boolean and is commonly used in if statements. There is also an ifPresent() method that takes a Consumer parameter and runs it only if the Optional is nonempty. Therefore, option D is correct."
    },
    {
      "number": 36,
      "answers": [
        "B"
      ],
      "explanation": "The lambda is a Supplier<Double>. Since the random() method is static, we need a static method reference. It uses :: to separate the class name and method name. Option B is correct. Options A, C, and D use syntax that is not supported with method references."
    },
    {
      "number": 37,
      "answers": [
        "D"
      ],
      "explanation": "Options A and B are incorrect because they are not operations in a stream pipeline. A source and the terminal operation are required parts of a stream pipeline and must occur exactly once. The intermediate operation is optional. It can appear zero or more times. Since more than one falls within zero or more, option D is correct."
    },
    {
      "number": 38,
      "answers": [
        "D"
      ],
      "explanation": "All of the code compiles. The first stream source has three elements. The intermediate operations both sort the elements of this stream and then we request one from findAny(). The findAny() method is not guaranteed to return a specific element. Since we are not using parallelization, it is highly likely that the code will print a. However, you need to know this is not guaranteed. Additionally, the stream on line 28 prints Optional[a], Optional[b], or Optional[c]. Since only lines 23–26 print a single character, option D is the answer."
    },
    {
      "number": 39,
      "answers": [
        "E"
      ],
      "explanation": "First, the forEach() method requires a Consumer instance. Option D can be immediately discarded because Supplier<Double> does not inherit Consumer. For this same reason, option C is also incorrect. DoubleConsumer does not inherit from Consumer. In this manner, primitive functional interfaces cannot be used in the forEach() method. Option A seems correct, since forEach() does take a Consumer instance, but it is missing a generic argument. Without the generic argument, the lambda expression does not compile because the expression p<5 cannot be applied to an Object. Option B is also close. However, a Double cannot be passed to an Integer. The correct functional interface is Consumer<Double>, and since that is not available, option E is the correct answer."
    },
    {
      "number": 40,
      "answers": [
        "A"
      ],
      "explanation": "Option A is the invalid lambda expression because the type is specified for the variable j, but not the variable k. The rest of the options are valid lambda expressions. To be a valid lambda expression, the type must be specified for all of the variables, as in option C, or none of them, as in options B and D."
    },
    {
      "number": 41,
      "answers": [
        "B"
      ],
      "explanation": "The code compiles and runs without issue. The three-argument reduce() method returns a generic type, while the one-argument reduce() method returns an Optional. The concat1() method is passed an identity 'a', which it applies to each element, resulting in the reduction to aCataHat. The lambda expression in the concat2() method reverses the order of its inputs, leading to a value of HatCat. For these reasons, option B is the correct answer."
    },
    {
      "number": 42,
      "answers": [
        "C"
      ],
      "explanation": "Options A and B take two Double input arguments and return a Double value, making them equivalent to each other. On the other hand, option C takes a single double value and returns a Double value. For this reason, it is different from the other two, making option C correct."
    },
    {
      "number": 43,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "For a concurrent reduction, the underlying type should be a thread-safe collection. For this reason, option A is incorrect and option E is correct. The streams must all be parallel, making option B correct and option F incorrect. Options C and D are incorrect, as there is no two-argument version of collect() within the Stream interface."
    },
    {
      "number": 44,
      "answers": [
        "E"
      ],
      "explanation": "Option A is the only one of the three options to compile. However, it results in no lines being output since none of the three strings is empty. Options B and C do not even compile because a method reference cannot have an operator next to it. Option D does not compile because String does not have an isNotEmpty() method. Therefore, option E is correct."
    },
    {
      "number": 45,
      "answers": [
        "C"
      ],
      "explanation": "The source of this stream is infinite. Sorting something infinite never finishes, so the stream pipeline never completes and option C is the answer."
    },
    {
      "number": 46,
      "answers": [
        "D"
      ],
      "explanation": "The code compiles and does not throw any exceptions at runtime, so options A and B are incorrect. The code snippet is serial, by default, so the order is predictable, making option F incorrect. The peek() method executes on each member of the pipeline, printing five numbers as the elements are then collected into a List, which gives us 345. They are then printed again, making the final output 345345 and option D correct."
    },
    {
      "number": 47,
      "answers": [
        "C"
      ],
      "explanation": "The Supplier functional interface normally takes a generic argument, although generic types are not strictly required since they are removed by the compiler. Therefore, line d1 compiles while triggering a compiler warning. On the other hand, line d2 does cause a compiler error, because the lambda expression does not return a value. Therefore, it is not compatible with Supplier, making option C the correct answer."
    },
    {
      "number": 48,
      "answers": [
        "B",
        "F"
      ],
      "explanation": "Primitive streams, like LongStream, declare an average() method that returns an OptionalDouble object. This object declares a getAsDouble() method rather than a get() method. Therefore, option B is correct. By contrast, the summary statistics classes provide getters in order to access the data. The getAverage() method returns a double and not an OptionalDouble, which makes option F correct."
    },
    {
      "number": 49,
      "answers": [
        "D"
      ],
      "explanation": "Remember that all Supplier interfaces take zero parameters. For this reason, the third value in the table is 0, making options A, C, and E incorrect. Next, DoubleConsumer and IntFunction each take one value, double and int, respectively. On the other hand, ObjDoubleConsumer takes two values, a generic value and a double, and returns void. For this reason, option D is correct, and option B is incorrect."
    },
    {
      "number": 50,
      "answers": [
        "F"
      ],
      "explanation": "All Consumer functional interfaces have a void return type. For this reason, the first and last values in the table are both void, making options A, B, and C incorrect. IntFunction takes an int and returns a generic value, ruling out option D. Finally, LongSupplier does not take any values and returns a long value. For this reason, option E is incorrect, and option F is correct."
    },
    {
      "number": 51,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles and runs without issue. The JVM will fall back to a single-threaded process if all of the conditions for performing the parallel reduction are not met. The stream used in the main() method is not parallel, but the groupingByConcurrent() method can still be applied without throwing an exception at runtime. Although performance will suffer from not using a parallel stream, the application will still process the results correctly. Since the process groups the data by year, option A is the correct answer."
    },
    {
      "number": 52,
      "answers": [
        "C"
      ],
      "explanation": "This code is almost correct. Calling two different streams is allowed. The code attempts to use a method reference when calling the forEach() method. However, it does not use the right syntax for a method reference. A double colon needs to be used. If the code were changed to System.out::println, it would print two lines for each call, for a total of four lines. Since it does not compile, option C is correct."
    },
    {
      "number": 53,
      "answers": [
        "C"
      ],
      "explanation": "First, option A does not compile since the variables p and q are reversed, making the return type of the method and usage of operators invalid. The first argument, p, is a String and q is an int, but the lambda expression reverses them, and the code does not compile. Option B also does not compile. The variable d is declared twice, first in the lambda argument list and then in the body of the lambda expression. The second declaration in the body of the lambda expression causes the compiler to generate a duplicate local variable message. Note that other than it being used twice, the expression is valid; the ternary operator is functionally equivalent to the learn() method in the BiologyMaterial class. Option C is the correct answer since it compiles and handles the input in the same way as the learn() method in the BiologyMaterial class. Option D compiles but does not return the same result."
    },
    {
      "number": 54,
      "answers": [
        "A",
        "F"
      ],
      "explanation": "This code does compile. Remember that imports are implied, including the static import for Collectors. The collector tries to use the number of characters in each stream element as the key in a map. This works fine for the first two elements, speak and bark, because they are of length 5 and 4, respectively. When it gets to meow, it sees another key of 4. The merge function says to use the first one, so it chooses bark for the value. Similarly, growl is five characters, but the first value of speak is used. There are only two distinct lengths, so option A is correct. If the stream had a null instead of \"meow\", then the code would throw a NullPointerException since we need to check the length of the String to determine which part of the Map it goes in. Since you cannot call a method on null, option F is also correct."
    },
    {
      "number": 55,
      "answers": [
        "A"
      ],
      "explanation": "Option A is correct as the source and terminal operation are mandatory parts of a stream pipeline. Option B is incorrect because a Stream must return objects. Specialized interfaces like IntStream are needed to return primitives. Option C is incorrect because Stream has methods such as of() and iterate() that return a Stream. Option D is incorrect because infinite streams are possible."
    },
    {
      "number": 56,
      "answers": [
        "F"
      ],
      "explanation": "Trick question! The correct method to obtain an equivalent parallel stream of an existing IntStream is parallel(), but for an IntStream this returns another IntStream, not a generic Stream<T>. The correct solution would be to call boxed().parallel(), but since this isn't available, option F is correct."
    },
    {
      "number": 57,
      "answers": [
        "A"
      ],
      "explanation": "We can rule out options C and D because they do not take any parameters, so they do not compile. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate checks if the element is greater than 5. With anyMatch(), the stream pipeline ends once element 6 is hit and the code prints true. For the allMatch() operator, it sees that the first element in the stream does not match and the code prints false. Similarly, the noneMatch() operator gets to the point where i is 6 and returns false because there is a match. Therefore, option A is correct."
    },
    {
      "number": 58,
      "answers": [
        "D"
      ],
      "explanation": "Option A is incorrect because it doesn't print out any text. The peek() method is an intermediate operation. Since there is no terminal operation, the stream pipeline is not executed, so the peek() method is never executed, and nothing is printed. Options B and C are incorrect because they correctly output one line using a method reference and lambda, respectively, and don't use any bad practices. Option D is the correct answer. It does output one line. However, it is bad practice to have a peek() method that has side effects like modifying a variable."
    },
    {
      "number": 59,
      "answers": [
        "C"
      ],
      "explanation": "The lambda expression compiles without issue, making option B incorrect. The task variable is of type UnaryOperator<Doll>, with the abstract method apply(). There is no accept() method defined on that interface, therefore the code does not compile, and option C is the correct answer."
    },
    {
      "number": 60,
      "answers": [
        "D"
      ],
      "explanation": "The code compiles and does not throw any exceptions at runtime, so options A and B are incorrect. As an element goes through the pipeline, it is printed once by the peek() method, then once by the forEach() method. For example, 0.1 0.1 0.54 0.54 0.6 0.6 0.3 0.3 is a possible output from this code. For this reason, option D is correct."
    },
    {
      "number": 61,
      "answers": [
        "B",
        "D",
        "F"
      ],
      "explanation": "The findAny() method is capable of returning any element of the stream regardless of whether it is serial, parallel, ordered, or unordered. For this reason, options B, D, and F are correct. Option C is actually invalid, as an unordered stream does not have a first element."
    },
    {
      "number": 62,
      "answers": [
        "C"
      ],
      "explanation": "To begin with, Consumer uses accept(), making option A incorrect. Next, Function and UnaryOperator use apply(), making options B and D, respectively, incorrect. Option E is also incorrect, as there is no Producer functional interface. Finally, Supplier uses get(), making option C the correct answer."
    },
    {
      "number": 63,
      "answers": [
        "C"
      ],
      "explanation": "Option D is incorrect as the syntax is fine. Option E is incorrect because there is a charAt() instance method. While option B is correct that the method takes an int parameter, autoboxing would take care of conversion for us if there were no other problems. So option B is not the answer either. Option A is not true because there are constructor and instance method references. This method reference could be assigned to BiFunction<String, Integer, Character>. However, it cannot be assigned to a Function. This makes option C the correct answer."
    },
    {
      "number": 64,
      "answers": [
        "B",
        "C",
        "D"
      ],
      "explanation": "While the second and third stream operations compile, the first does not. The parallel() method should be applied to a stream, while the parallelStream() method should be applied to a Collection<E>. For this reason, option A is incorrect, and options B and C are correct. Neither the second nor the third stream operation is expected to produce an exception at runtime, making option D correct and option E incorrect. Note that calling parallel() on an already parallel stream is unnecessary but allowed. Finally, the output of the second and third stream operations will vary at runtime since the streams are parallel, making option F incorrect."
    },
    {
      "number": 65,
      "answers": [
        "D"
      ],
      "explanation": "Since the code uses a BiPredicate, it takes two parameters in the test() call. The first is the instance of String and the second is the substring value to check. Since both parameters are passed in, we use the type of String in the method reference, making option D the correct answer."
    },
    {
      "number": 66,
      "answers": [
        "C"
      ],
      "explanation": "This code compiles. It creates a stream of Ballot objects. Then it creates a map with the contestant's name as the key and the sum of the scores as the value. For Mario, this is 10 + 9, or 19, so option C is correct."
    },
    {
      "number": 67,
      "answers": [
        "D"
      ],
      "explanation": "The map() method can fill in the blank. The lambda converts a String to an int, and Java uses autoboxing to turn that into an Integer. The mapToInt() method can also fill in the blank, and Java doesn't even need to autobox. There isn't a mapToObject() in the stream API. Note there is a similarly named mapToObj() method on IntStream. Since both map() and mapToInt() work here, option D is correct."
    },
    {
      "number": 68,
      "answers": [
        "A",
        "C"
      ],
      "explanation": "This is a correct example of code that uses a lambda. The interface has a single abstract method. The lambda correctly takes one double parameter and returns a boolean. This matches the interface. The lambda syntax is correct. Since it compiles, option C is correct. Finally, option A is correct because 45 is greater than 5."
    },
    {
      "number": 69,
      "answers": [
        "C"
      ],
      "explanation": "The reduction is parallel, but since the accumulator and combiner are well-behaved (stateless and associative), the result is consistent, making option D incorrect. The identity is 1, which is applied to every element, meaning the operation sums the values (1+1), (1+2), and (1+3). For this reason, 9 is consistently printed at runtime, making option C correct."
    },
    {
      "number": 70,
      "answers": [
        "E"
      ],
      "explanation": "The average() method returns an OptionalDouble. This interface has a getAsDouble() method rather than a get() method, so the code does compile. However, the stream is empty, so the optional is also empty. When trying to get the value on line 12, the code throws a NoSuchElementException, making option E correct."
    },
    {
      "number": 71,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "Options A and D are incorrect since they are missing the arrow (->), which makes them lambdas. Options C and F are incorrect, as they try to mix lambdas and method references. This leaves options B and E as the answers."
    },
    {
      "number": 72,
      "answers": [
        "F"
      ],
      "explanation": "Both Collectors.groupingBy() and Collectors.partitioningBy() are useful for turning a stream into a Map. The other two methods mentioned do not exist. The partitioningBy() method automatically groups using a Boolean key. However, we can also have a Boolean key with groupingBy(). For example, we could write s -> s.length() > 3. Therefore, option F is correct."
    },
    {
      "number": 73,
      "answers": [
        "B"
      ],
      "explanation": "Option A is incorrect because \"3\" is a String, which is not compatible with the return type int required for IntSupplier. Option B is the correct answer. Although this will result in a divide-by-zero issue at runtime, the lambda is valid and compatible with IntSupplier. Option C is incorrect because the lambda expression is invalid. The return statement is allowed only inside a set of braces ({}). Finally, option D is incorrect. The method reference is used for Consumer, not Supplier, since it takes a value and does not return anything."
    },
    {
      "number": 74,
      "answers": [
        "A"
      ],
      "explanation": "The code compiles without issue, so options C and D are incorrect. The value for distance is 2, which based on the lambda for the Predicate will result in a true expression, and Saved will be printed, making option A correct."
    },
    {
      "number": 75,
      "answers": [
        "E"
      ],
      "explanation": "The correct method to obtain a parallel stream from a Collection<E> is parallelStream(), making option E correct."
    },
    {
      "number": 76,
      "answers": [
        "C"
      ],
      "explanation": "The filter() method takes a Predicate, which requires a boolean return type from the lambda or method reference. The getColor() method returns a String and is not compatible. This causes the code to not compile and option C to be the answer."
    },
    {
      "number": 77,
      "answers": [
        "B",
        "E"
      ],
      "explanation": "The generate() and iterate() sources return an infinite stream. Further, the of() source returns a finite stream, which shows option B is one of the answers. The limit() intermediate operation returns a finite stream. When given an infinite stream, the map() intermediate operation keeps the infinite stream, which means option E is the other correct answer."
    },
    {
      "number": 78,
      "answers": [
        "E"
      ],
      "explanation": "Like a lambda, method references use type inference. When assigned to a local variable, var cannot be used because there is not enough information to infer the type. Because of this, lines 17, 18, and 19 do not compile. Consumer<Object> takes a single Object argument and does not return any data. The ArrayList and String classes do not contain constructors that take an Object, so lines 14 and 15 do not compile either. Line 16 does support an Object variable, since the System.out.println(Object) method exists. For these reasons, option E is the correct answer."
    },
    {
      "number": 79,
      "answers": [
        "E"
      ],
      "explanation": "Based on the reduction operation, the data types of w, y, and z are Integer, while the data type of x is StringBuilder. Since Integer does not define a length() method, both the accumulator and combiner lambda expressions are invalid, making option E correct."
    },
    {
      "number": 80,
      "answers": [
        "C",
        "F"
      ],
      "explanation": "The first intermediate operation, limit(1), gets rid of the null. The partitioningBy() method returns a map with two keys, true and false, regardless of whether any elements actually match. If there are no matches, the value is an empty list, making option C correct. If line k is removed, the code throws a NullPointerException since null is neither true nor false. Therefore, option F is the other answer."
    },
    {
      "number": 81,
      "answers": ["D"],
      "explanation": "The code does not compile because flatMapToInt() requires a Function with a return value of IntStream, not Stream<Integer>, making option D correct."
    },
    {
      "number": 82,
      "answers": ["D"],
      "explanation": "A lambda expression can match multiple functional interfaces, but when UnaryOperator is used without a generic argument, the type is assumed to be Object. Since the addition operator is not defined on Object, the code does not compile due to the lambda expression body, making option D the correct answer."
    },
    {
      "number": 83,
      "answers": ["B", "D"],
      "explanation": "Applying forEachOrdered() to a parallel stream forces the terminal operation to be performed in a single-threaded, rather than parallel, manner. For this reason, it is likely that it will be slower, making option B correct. Intermediate operations can still take advantage of parallel processing, since forEachOrdered() is only applied at the end of the pipeline. For this reason, option D is also correct."
    },
    {
      "number": 84,
      "answers": ["C", "F"],
      "explanation": "The code does not compile because the class should be IntSummaryStatistics, not IntegerSummaryStatistics. This makes option C correct. The purpose of using the summary statistics class is to avoid multiple trips through the stream pipeline, making option F the other answer."
    },
    {
      "number": 85,
      "answers": ["C"],
      "explanation": "Both lambda and method references can accept a parameter and be executed later, ruling out options A and D. One big difference is with a lambda like: () -> s.charAt(3). The s variable must be final or effectively final variable in both lambdas and method references, making option B incorrect. However, there isn't a way to use the hard-coded number in a method reference. Therefore, option C is a difference and the answer."
    },
    {
      "number": 86,
      "answers": ["D"],
      "explanation": "All but the last line compile and print 3, making option D the answer. The last line does not compile because addition is not allowed on a generic stream."
    },
    {
      "number": 87,
      "answers": ["E"],
      "explanation": "A stream pipeline is allowed to have zero or more intermediate operations. This means both filter() and sorted() can be removed. The source and terminal operations are required, so cannot be removed. Therefore, generate() and findFirst() must stay. The ifPresent() call is not part of the stream pipeline. It is a method on Optional. Option E matches the methods we can remove."
    },
    {
      "number": 88,
      "answers": ["B", "C", "E"],
      "explanation": "The orElseThrow() method throws a NoSuchElementException when the Optional is empty. Since this exception is not caught, a stack trace is printed, matching option B. The overloaded method that takes a parameter throws the specified exception. Since we do catch an IllegalArgumentException, the code prints the message, which is option C. Finally, the orElse() method returns the specified string and option E is correct."
    },
    {
      "number": 89,
      "answers": ["C"],
      "explanation": "Predicate<T> is a generic interface with one method. The method signature is boolean test(T t). Option C is the answer because the method accepts one parameter rather than two."
    },
    {
      "number": 90,
      "answers": ["B", "C"],
      "explanation": "The BiFunction interface takes two different generic values and returns a generic value, requiring a total of three generic arguments. ToDoubleFunction takes exactly one generic value and returns a double value, requiring one generic argument. Therefore, options B and C are correct."
    },
    {
      "number": 91,
      "answers": ["C"],
      "explanation": "To execute a parallel reduction with the collect() method, the stream or Collector must be unordered, the Collector must be concurrent, and the stream must be parallel. Since an unordered Set is used as the data source, the first property is fulfilled. To be a parallel reduction, though, Collectors.groupingByConcurrent() should be used instead of Collectors.groupingBy(). In addition, parallelStream() should be called on the Set, instead of stream(). For these two reasons, option C is correct."
    },
    {
      "number": 92,
      "answers": ["D"],
      "explanation": "This is a correct stream pipeline. The source creates a stream of three elements. The first operation makes a stream of one element, one. Then that single element is made uppercase and sorted to complete the intermediate operations. Finally, the terminal operation prints ONE, which corresponds to option D."
    },
    {
      "number": 93,
      "answers": ["B"],
      "explanation": "BinaryOperator<Long> takes two Long arguments and returns a Long value. Option A, which takes one argument, and option D, which takes two Integer values that do not inherit from Long, are both incorrect. Option C is incorrect because the local variable c is re-declared inside the lambda expression, causing the expression to fail to compile. The correct answer is option B because intValue() can be called on a Long object. The result is then cast to long, which is autoboxed to Long."
    },
    {
      "number": 94,
      "answers": ["A"],
      "explanation": "BooleanSupplier is the only functional interface that does not involve double, int, or long, making option A the correct answer. The others do not exist in the java.util.function package."
    },
    {
      "number": 95,
      "answers": ["D", "F"],
      "explanation": "Certain stream operations, such as limit() or skip(), force a parallel stream to behave in a serial manner, so option A is incorrect and option F is correct. Option B is also incorrect. The stream must be explicitly set to be parallel in order for the JVM to apply a parallel operation. Option C is incorrect because parallel stream operations are not synchronized. It is up to the developer to provide synchronization or use a concurrent collection if required. Option D is correct. The BaseStream interface, which all streams inherit, includes a parallel() method. Of course, the results of an operation may change in the presence of a parallel stream, such as using a problematic (non-associative) accumulator. For this reason, option E is incorrect."
    },
    {
      "number": 96,
      "answers": ["E"],
      "explanation": "The sorted() method allows an optional Comparator to be passed as a reference. However, Comparator.reverseOrder() does not implement the Comparator interface. It takes zero parameters instead of the required two. Since it cannot be used as a method reference, the code does not compile, and option E is correct."
    },
    {
      "number": 97,
      "answers": ["F"],
      "explanation": "The mapToDouble() method compiles. However, it converts 9 into 9.0 rather than the single digit 9. The mapToInt() method does not compile because a long cannot be converted into an int without casting. The mapToLong() method is not available on LongStream so it does not compile. It is available on DoubleStream, IntStream, and Stream implementations. Since none of the options outputs the single digit 9, option F is correct."
    },
    {
      "number": 98,
      "answers": ["E"],
      "explanation": "The code does not compile because the lambda expression p -> p*100 is not compatible with the DoubleToIntFunction functional interface. The input to the functional interface is double, meaning p*100 is also double. The functional interface requires a return value of int, and since double cannot be implicitly cast to int, the code does not compile, making option E the correct answer."
    },
    {
      "number": 99,
      "answers": ["A", "E"],
      "explanation": "Stateful lambda expressions should be avoided with both serial and parallel streams because they can lead to unintended side effects, making option A correct. A common way to remove a stateful lambda expression that modifies a List is to have the stream operation output a new List. For this reason, option E is correct. Options D and F are incorrect because, while a concurrent or synchronized list may make the stream operation thread-safe, they are still stateful lambda expressions."
    },
    {
      "number": 100,
      "answers": ["E"],
      "explanation": "The code does not compile, making option E the answer. In particular, the call to test() should have one parameter instead of two."
    },
    {
      "number": 101,
      "answers": ["B"],
      "explanation": "Lazy evaluation delays execution until it is needed. Option B is the only one that matches this requirement. While option A is true, this can be done without lazy evaluation. Option C requires parallelization rather than deferred execution. Option D is incorrect, as losing the data is bad. Finally, pipelines are run by the computer, which does not get tired."
    },
    {
      "number": 102,
      "answers": ["F"],
      "explanation": "The distinct() and filter() methods can reduce the number of elements in a stream but do not change the generic type, making options A and E incorrect. The iterate() method is static and creates a new stream. It cannot be applied to an existing stream, making option B incorrect. The peek() and sorted() methods do not alter the generic type of the stream, making options C and D incorrect. For these reasons, option F is correct."
    },
    {
      "number": 103,
      "answers": ["B", "F"],
      "explanation": "Option B fills in the first blank because BiFunction includes the apply() method. DoubleUnaryOperator contains the applyAsDouble() method, making option F correct. For the exam, pay attention to methods that have a different name for primitives."
    },
    {
      "number": 104,
      "answers": ["A"],
      "explanation": "The sorted() method takes an optional Comparator as the parameter, which takes two String parameters and returns an int. Option A is correct because the lambda implements this interface. Option B is incorrect because the method reference doesn't return an int. While generate() starts with an infinite stream, the limit() intermediate operation immediately makes it finite. Finally, the distinct() intermediate operation gives us one star instead of three."
    },
    {
      "number": 105,
      "answers": ["D"],
      "explanation": "Options A, B, and C are true statements about functional interfaces. A lambda may be compatible with multiple functional interfaces, but it must be assigned to a functional interface when it is declared or passed as a method argument. Also, a method can be created with the return type that matches a functional interface, allowing a lambda expression to be returned. Option D is the correct answer. Deferred execution means the lambda expression is not evaluated until runtime, but it is compiled. Compiler errors in the lambda expression will still prevent the code from compiling."
    },
    {
      "number": 106,
      "answers": ["B", "F"],
      "explanation": "Line 25 creates a Spliterator containing four toys. Line 26 splits them into two equal groups by removing the first half of the elements and making them available to batch. On line 28, we remove Jack in the Box from batch passing it to a lambda that doesn't print anything. Line 29 prints true since Slinky is still in batch. Therefore, option B is one of the answers. Option F is the other correct answer since Yo-Yo is the first toy in the half that remained in the original spliterator."
    },
    {
      "number": 107,
      "answers": ["F"],
      "explanation": "We can rule out options C and D because they do not take any parameters, so they do not compile. Further, this code generates an infinite stream of the number 1. The Predicate checks if the element is greater than 5. This will never be true. With allMatch(), the stream pipeline ends after checking the first element. It doesn't match, so the code prints false. Both anyMatch() and noneMatch() keep checking and don't find any matches. However, they don't know if a future stream element will be different, so the code executes infinitely until the process is terminated. Therefore, option F is correct."
    },
    {
      "number": 108,
      "answers": ["D"],
      "explanation": "Line 5 needs to be modified to take a second generic argument since it uses Function. Second, the assignment statement on line 7 is missing an ending semicolon (;). Finally, the forEach() method on line 10 needs to be commented out since it requires a Consumer, not a Function. Alternatively, you can change Function to Consumer, add the missing semicolon, and remove the return from the lambda. Since either of these approaches is three changes, option D is the correct answer."
    },
    {
      "number": 109,
      "answers": ["A", "D", "E"],
      "explanation": "The findFirst() method always returns the first element on an ordered stream, regardless if it is serial or parallel, making options A and E correct. Option D is also correct, as it is free to return any element if the stream is unordered. Option C is actually invalid, as an unordered stream does not have a first element."
    },
    {
      "number": 110,
      "answers": ["E"],
      "explanation": "The only one of these references to compile is option D. However, the original code prints Carrying 1. The version with a method reference would just print 1. Option E is the answer because this is not the same output."
    },
    {
      "number": 111,
      "answers": ["F"],
      "explanation": "A stream cannot be used again once it is executed. Line 21 creates a stream. Line 22 creates a second stream; however, the reference is lost on line 23. Lines 23 and 24 add intermediate operations to the stream that was created on line 21. Due to lazy evaluation, they do not run until line 25 executes the stream pipeline and prints 0. However, line 26 attempts to execute the same stream and throws an IllegalStateException. This matches option F."
    },
    {
      "number": 112,
      "answers": ["A", "B", "F"],
      "explanation": "Options A and B are correct because the type may be var or omitted in a lambda. If there are multiple parameters, all must be handled the same way. Option C is incorrect as a Predicate cannot have zero parameters. Option D is incorrect because -> separates parts of a lambda. Option E is incorrect because return is allowed only when braces are present. Option F is correct."
    },
    {
      "number": 113,
      "answers": ["E"],
      "explanation": "The newValue variable is locally scoped to the lambda. It is not available outside the lambda, so the println() does not compile, and option E is the answer."
    },
    {
      "number": 114,
      "answers": ["D"],
      "explanation": "The DoubleToLongFunction interface takes a double argument and returns a long value. Option A is compatible because the int value 1 can be implicitly cast to long, and 2L is already a long. Option B is also compatible because the double value 10.0*e is explicitly cast to int then implicitly cast to long. Option C is compatible because an explicit cast of the double to a long value is used. Option D cannot be assigned and is the correct answer. The lambda expression violates the signature of the functional interface, as it allows Double values to be sent to the interface, including those that could be null."
    },
    {
      "number": 115,
      "answers": ["B", "D"],
      "explanation": "Option A is incorrect because sets are unordered. Options C and F are incorrect because they do not compile. Option E is incorrect because the accumulator and combiner in the divide() method are not well-behaved and are not associative. Option B is correct because the stream has only one element, so the identity is the only thing that will be applied. Option D is correct because the parallel() method is used to obtain an equivalent parallel stream of an existing stream."
    },
    {
      "number": 116,
      "answers": ["C"],
      "explanation": "Four of the five examples print miny. Option C does not compile. The difference is that partitioningBy() requires a Predicate that returns a boolean. When you get a question like this on the exam, focus on the differences between the provided options."
    },
    {
      "number": 117,
      "answers": ["D"],
      "explanation": "The correct method to obtain an equivalent parallel stream of an existing stream is parallel(), which is inherited by any class that implements BaseStream<T>, including the primitive streams. For this reason, option D is correct."
    },
    {
      "number": 118,
      "answers": ["B"],
      "explanation": "Method references are a shorter way of writing lambdas, and all method references can be expanded to lambdas. However, this does not apply in reverse. The lambda () -> s.charAt(3) cannot accept the hardcoded number 3 as a method reference parameter. Since only method references can always be converted, option B is correct."
    },
    {
      "number": 119,
      "answers": ["D"],
      "explanation": "Options A and B are incorrect because the second functions for both return a double or Double value, respectively, which cannot be sent to a UnaryOperator<Integer> without an explicit cast. Option C is incorrect because the first functional interface Function<Double,Integer> takes only one input, but the diagram shows two inputs for the first functional interface. Option D is correct because it correctly matches the behaviors of the functional interfaces in the diagram."
    },
    {
      "number": 120,
      "answers": ["A", "B", "E"],
      "explanation": "The DoublePredicate interface takes a double value and returns a boolean value. LongUnaryOperator takes a long value and returns a long value. ToIntBiFunction takes two generic values and returns an int value. For these reasons, options A, B, and E are correct. NullOperator, ShortSupplier, and ToStringOperator are not built-in functional interfaces."
    },
    {
      "number": 121,
      "answers": ["D"],
      "explanation": "The lambda expression is invalid because the input argument is of type Boss, and Boss does not define an equalsIgnoreCase() method, making option D the correct answer. If the lambda was corrected to use s.toString() instead of s, the code would compile and run without issue, printing [PETER, MICHAEL] at runtime and making option A the correct answer."
    },
    {
      "number": 122,
      "answers": ["E"],
      "explanation": "Serval is not a valid interface, let alone a functional interface. The cat() method specifies an implementation but does not have one of the modifiers that allows a body: default, private, or static. For this reason, option E is correct."
    },
    {
      "number": 123,
      "answers": ["A"],
      "explanation": "Comparator returns an int, causing lines 17 and 18 to not compile. Supplier does not take any parameters further, ruling out lines 21 and 22. Predicate at least has the right number of parameters and the correct boolean return type. However, line 19 is not correct because the parentheses are missing around the type and variable. The parentheses can be omitted only if no type declaration is present, making line 20 correct. Since only one of these lines of code compiles, option A is the answer."
    },
    {
      "number": 124,
      "answers": ["D"],
      "explanation": "The code is correct, ruling out options E, F, and G. There are three Pet records, and the ages add up to 15, making option D the answer."
    },
    {
      "number": 125,
      "answers": ["A"],
      "explanation": "Option A is the answer because there is a getCount() method that returns a long rather than a method named getCountAsLong(). Option B is incorrect because there is in fact a getMax() method. Option C is incorrect because toString() is declared on Object, which means it is inherited by all classes."
    },
    {
      "number": 126,
      "answers": ["A"],
      "explanation": "The method reference System.out::println takes a single input and does not return any data. Consumer<Sheep> is compatible with this behavior, making option A the correct answer. Option B does not compile because void cannot be used as a generic argument. Option C does not take a parameter. Option D is incorrect since System.out::println() does not return any data, and UnaryOperator requires a return value."
    },
    {
      "number": 127,
      "answers": ["C", "E", "F"],
      "explanation": "The correct method to obtain a parallel stream of an arbitrary stream is parallel(), while the correct method to obtain a parallel stream that operates on a Collection is parallelStream(). For this reason, options C, E, and F are correct. Note that option E retrieves a parallel stream of an already parallel stream, which is allowed."
    },
    {
      "number": 128,
      "answers": ["A", "F"],
      "explanation": "The code, as written, prints rabbit since it starts with the letter r. This is option A. The prefix variable is effectively final and therefore safe to use in a lambda. Uncommenting line 7 changes the prefix variable, and it is no longer effectively final. Since this causes a compiler error, option F is the other answer."
    },
    {
      "number": 129,
      "answers": ["B"],
      "explanation": "The code compiles, so options E and F are incorrect. The stream operations on lines 12–13 reduce the stream to the values [2, 3, 4]. Line 14 then converts the Stream<Integer> to an IntStream. On line 15, the first element of the IntStream is skipped, so the stream has only two elements [3, 4]. On lines 16–17, the IntStream is converted to a Stream<Integer>, then a DoubleStream. Finally, on lines 18–19 the sum of the remaining elements is calculated and printed. Since 7.0 is printed, option B is correct."
    },
    {
      "number": 130,
      "answers": ["B"],
      "explanation": "Since the first two rows are already finite streams, boxes M and N do not require an intermediate operation to complete, so options D, E, and F are incorrect. Box P does not need an intermediate operation either since findFirst() will cause the stream to terminate, making options A and C incorrect. Box O does need to be filled in with code such as limit(1). This allows the code to terminate, and option B is the answer."
    },
    {
      "number": 131,
      "answers": ["C"],
      "explanation": "Since the first two rows are already finite streams, boxes M and N meet these criteria. The last two rows can be filled in with code such as sorted(), which does not terminate for an infinite stream. Therefore, neither allows the code to terminate, and option C is the answer."
    },
    {
      "number": 132,
      "answers": ["C"],
      "explanation": "A Comparator takes two parameters, so options A and B are incorrect. Option D doesn't compile. When returning a value using braces, a return keyword and semicolon are required. Option C is a correct implementation."
    },
    {
      "number": 133,
      "answers": ["E"],
      "explanation": "The anyMatch(), allMatch(), and noneMatch() methods take a Predicate as a parameter. This code does not compile because the parameter is missing, making option E correct."
    },
    {
      "number": 134,
      "answers": ["B"],
      "explanation": "Since the lambda references an effectively final variable, the method reference needs to as well. Option B is a correct method reference that meets this criteria. Options A and C use syntax that is not supported with method references. Option D is incorrect because the Predicate passes only one value at runtime, so either the instance variable or method parameter would need to be supplied."
    },
    {
      "number": 135,
      "answers": ["E"],
      "explanation": "Both pred4 and pred5 are valid, as they use a type or var without final. Both pred1 and pred3 are valid because the final modifier can only be used if a type or var is specified. Since pred2 is missing a data type and is the only line that does not compile, option E is the answer."
    },
    {
      "number": 136,
      "answers": ["A"],
      "explanation": "This code does compile, making options D and E incorrect. It correctly uses a Predicate<String> and removes all the elements from names and prints out 0. Therefore, option A is the answer."
    },
    {
      "number": 137,
      "answers": ["B"],
      "explanation": "Since it's not a primitive stream, the underlying type is Stream<Integer>, which means the data type of x is Integer. On the other hand, the data type of w, y, and z is Float. Because Integer and Float both define a floatValue() method, all of the lines compile. The code snippet prints 9.0 at runtime, making option B correct."
    },
    {
      "number": 138,
      "answers": ["B"],
      "explanation": "The flatMap() method is used to turn a stream of collections into a one-dimensional stream. This means it gets rid of the empty list and flattens the other two. Option A is incorrect because this is the output you'd get using the regular map() method. Option B is correct because it flattens the elements. Notice how it doesn't matter that all three elements are different types of Collection implementations."
    },
    {
      "number": 139,
      "answers": ["D"],
      "explanation": "Pay attention to the data types. The forEach() method is looping through a list of objects. This is a good example of using a lambda with list. By contrast, the Predicate passed to removeIf() uses an Integer. Since Integer is not compatible with String, line 8 does not compile and option D is the answer."
    },
    {
      "number": 140,
      "answers": ["C"],
      "explanation": "To start with, IntFunction<Integer> takes an int value and returns an Integer. Line 8 takes an Integer instead of int as the input argument and is therefore not compatible. Line 9 is compatible, since the return type null can be used as an Integer return type. Line 10 is also valid. An int can be autoboxed to Integer. Lines 11 and 12 do not compile because they do not take a parameter. Since only two statements compile, option C is the correct answer."
    },
    {
      "number": 141,
      "answers": ["C", "D", "F"],
      "explanation": "Using a parallel stream does not guarantee concurrent execution or a specific number of threads, making option A incorrect. Option B is also incorrect, as stateful lambda expressions should be avoided with all streams, serial or parallel. In fact, if a stateful lambda expression is used, the result of the stream may change, making option F correct and option E incorrect. Option C is correct, as a parallel stream may improve performance. Option D is also correct, though, as a parallel stream may add extra overhead to a stream that is forced into a serial operation, such as when the findFirst() method is called."
    },
    {
      "number": 142,
      "answers": ["A"],
      "explanation": "The code compiles, so options D and E are incorrect. The code first splits the stream into a Map<Boolean, List<String> based on whether the landmark contains a space. Using the flatMap() method, it then takes the List<String> values of the Map and reforms them as a Stream<String>. This new stream is similar to the original stream, although with elements in a possibly different order. Finally, the groupingBy() collector splits the stream based on whether it does not start with an 'S'. Since Set and Map were used, the order may vary, but option A is one possible output."
    },
    {
      "number": 143,
      "answers": ["E"],
      "explanation": "Option A doesn't compile because the get() method on Optional doesn't take any parameters. Options B, C, and D do compile but print Cupcake since the Optional is not empty. Therefore, option E is correct."
    },
    {
      "number": 144,
      "answers": ["F"],
      "explanation": "There is no source in this attempt at a stream pipeline. While a Collection does have some of the same methods as a stream, such as forEach(), the limit() method is not one of them, so the code as written causes a compile error. Since this error is not on line x, option F is the answer."
    },
    {
      "number": 145,
      "answers": ["E"],
      "explanation": "The num variable is not effectively final because the value changes. This means it cannot be used in a lambda and the code does not compile, which is option E."
    },
    {
      "number": 146,
      "answers": ["D"],
      "explanation": "There is not a stream pipeline method called sort(). There is one called sorted(). Since the code does not compile, option D is correct. If sorted() were used, then the output would be 689."
    },
    {
      "number": 147,
      "answers": ["A"],
      "explanation": "A lambda can only implement an interface with a single abstract method, ruling out option B. Developers can write their own functional interfaces, making option A correct."
    },
    {
      "number": 148,
      "answers": ["C"],
      "explanation": "The primitive Supplier functional interfaces, such as BooleanSupplier and LongSupplier, do not have a get() method. Instead, they have methods such as getAsBoolean() and getAsLong(), respectively. For this reason, the first line of the checkInventory() method does not compile, making option C the correct answer."
    },
    {
      "number": 149,
      "answers": ["E"],
      "explanation": "The code does not compile because the collector returns a ConcurrentMap, which requires a BiConsumer in the forEach() method. For this reason, option E is correct."
    },
    {
      "number": 150,
      "answers": ["D"],
      "explanation": "When calling Stream.concat(), we need to pass Stream references, not IntStream. The code does not compile as written and option D is the answer."
    }
  ]
}